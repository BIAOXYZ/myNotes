
【[:star:][`*`]】 GCC常用参数详解 https://www.cnblogs.com/zhangsir6/articles/2956798.html
- > gcc and g++现在是gnu中最主要和最流行的c & c++编译器 .gcc/g++在执行编译工作的时候，总共需要以下几步:
  ```console
  1.预处理,生成.i的文件[预处理器cpp]
  2.将预处理后的文件不转换成汇编语言,生成文件.s[编译器egcs]
  3.有汇编变为目标代码(机器代码)生成.o的文件[汇编器as]
  4.连接目标代码,生成可执行程序[链接器ld]
  ```
- > GCC能够处理的后缀有:
  ```console
  a. *.c *.C (C语言)
  b. *.cxx *.cc (C++语言)
  c. *.m (面向对象的C)
  d. *.i (预处理后的C语言源文件)
  e. *.ii (预处理后的C++语言源文件)
  f. *.s *.S (汇编语言)
  h. *.h (头文件)
  ```
- > 目标文件可以是：
  ```console
  a. *.o 编译连接后的目标文件
  b. *.a 库文件
  ```
- > 误区一:gcc只能编译c代码,g++只能编译c++代码
  * > 两者都可以，但是请注意：
  * > 1.后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。
  * > 2.编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。
 - > 误区二:gcc不会定义__cplusplus宏，而g++会
  * > 实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。
 - > 误区三:编译只能用gcc，链接只能用g++
  * > 严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价
