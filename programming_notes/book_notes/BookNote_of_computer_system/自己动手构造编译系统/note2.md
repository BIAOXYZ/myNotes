
# 第二章 编译系统设计
> 正所谓“麻雀虽小，五脏俱全”，本章从全局的角度描述了编译系统的基本结构，并按照编译、汇编和链接的流程来介绍其设计。

## 2.1 编译程序的设计
> 编译器是编译系统的核心，主要负责解析源程序的语义，生成目标机器代码。一般情况下，编译流程包含 ***`词法分析`***、***`语法分析`***、***`语义分析`*** 和 ***`代码生成`*** 四个阶段。***`符号表管理`*** 和 ***`错误处理`*** 贯穿于整个编译流程。***如果编译器支持代码优化，那么还需要优化器模块***。

> `图2-1 编译器结构`

### 2.1.1 词法分析
> 现在假定我们拥有一段使用C语言书写的源程序，词法分析器通过对源文件的扫描获得高级语言定义的 ***`词法记号`***。所谓词法记号（也称为 ***`终结符`***），反映在高级语言语法中就是对应的`标识符`、`关键字`、`常量`，以及`运算符`、`逗号`、`分号等界符`。见`图2-2`。

> `图2-2 词法分析功能`

> 例如语句： `var2=var1+100;` 该语句包含了6个词法记号，它们分别是：“var2”、“=”、“var1”、“+”、“100”和分号。

> 对词法分析器的要求是能正常识别出这些不同形式的词法记号。词法分析器的 ***输入是源代码文本文件内一长串的文本内容***，那么如何从文本串中分析出每个词法记号呢？为了解决这个问题，需要引入 ***`有限自动机`*** 的概念。
> 
> 有限自动机能解析并识别词法记号，比如 ***识别标识符的有限自动机、识别常量的有限自动机等***。有限自动机从开始状态启动，读入一个字符作为输入，并根据该字符选择进入下一个状态。继续读入新的字符，直到遇到结束状态为止，读入的所有字符序列便是有限自动机识别的词法记号。
> 
> `图2-3`描述了识别标识符的有限自动机。C语言标识符的定义是：一个不以数字开始的由下划线、数字、字母组成的非空字符串。图中的自动机从0号状态开始，读入一个下划线或者字母进入状态1，状态1可以接受任意数量的下划线、字母和数字，同时状态1也是结束状态，一旦它读入了其他异常字符便停止自动机的识别，这样就可以识别任意一个合法的标识符。如果在非结束状态读入了异常的字符，意味着发生了词法错误，自动机停止（当然，上述标识符的有限自动机不会出现错误的情况）。

> 使用有限自动机，可以识别出自定义语言包含的所有词法记号。***把这些词法记号记录下来，作为下一步语法分析的输入***。如果使用一遍编译方式，就不用记录这些词法记号，而是直接将识别的词法记号送入语法分析器进行处理。

### 2.1.2 语法分析
> ***`词法分析器`的输入是`文本字符串`，`语法分析器`的输入则是`词法分析器识别的词法记号序列`***。语法分析器的输出不再是一串线性符号序列，而是一种树形的数据结构，通常称之为 ***`抽象语法树`***。见`图2-4`。
>
> 图2-4 语法分析功能

> 继续前面赋值语句的例子，我们可以先看看它可能对应的抽象语法树，如`图2-5`所示。
> 
> 图2-5 抽象语法树示例

> 从`图2-5`中可以看出，***所有的`词法记号`都出现在树的`叶子节点`上***，我们称 ***这样的`叶子节点`为`终结符`***。而所有的`非叶子节点`，都是对一串词法记号的抽象概括，我们称之为 ***`非终结符`***，可以将非终结符看作一个单独的语法模块（***抽象语法子树***）。其实，***整个源程序是一棵完整的抽象语法树，它由一系列语法模块按照树结构组织起来***。`语法分析器`就是要 ***获得源程序的抽象语法树表示***，这样才能让编译器具体识别每个语法模块的含义，分析出程序的整体含义。
> 
> 在介绍语法分析器的工作之前，需要先获得 ***高级语言语法的形式化表示***，即 ***`文法`***。***`文法`定义了源程序代码的书写规则，同时也是`语法分析器`构造`抽象语法树`的规则***。如果要定义 ***赋值语句的文法***，一般可以表达成如下 ***`产生式`*** 的形式： ***`<赋值语句> => 标识符 等号 <表达式> 分号`***
> 
> 被“`< >`”括起来的内容表示`非终结符`，终结符直接书写即可，上式可以读作“赋值语句推导出标识符、等号、表达式和分号”。显然，***表达式也有相关的文法定义***。根据定义好的高级语言特性，可以设计出相应的高级语言的文法，使用文法可以准确地表达高级语言的语法规则。
> 
> 有了高级语言的`文法`表示，就可以构造`语法分析器`来生成`抽象语法树`。在编译原理教材中，描述了很多的文法分析算法，有自顶向下的`LL（1）分析`，也有自底向上的`算符优先分析`、`LR分析`等。其中最常使用的是`LL（1）`和`LR分析`。相比而言，`LR分析器`能力更强，但是分析器设计比较复杂，不适合手工构造。我们设计的高级语言文法，只要稍加约束便能使`LL（1）分析器`正常工作，因此本书采用`LL（1）分析器`来完成语法分析的工作。***`递归下降子程序`*** 作为`LL（1）算法`的一种便捷的实现方式，非常适合手工实现语法分析器。`递归下降子程序`的基本原则是：***将`产生式左侧的非终结符`转化为函数定义，将`产生式右侧的非终结符`转化为函数调用，将`终结符`转化为词法记号匹配***。

> 每次对子程序的调用，就是按照前序的方式对该抽象语法子树的一次构造。例如在构造赋值语句子树时，会先构造“赋值语句”根节点，然后依次匹配标识符、等号子节点。当遇到下一个非终结符时，会进入对应的“表达式”子程序内继续按照前序方式构造子树的子树。最后匹配当前子程序的最后一个子节点，完成“赋值语句”子树的构造。整个语法分析就是按照这样的方式构造“程序”树的一个过程，***一旦在终结符匹配过程中出现读入的词法记号与预期的词法记号不吻合的情况，便会产生语法错误***。

### 2.1.3 符号表管理
