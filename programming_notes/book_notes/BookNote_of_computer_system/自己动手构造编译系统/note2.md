
# 第二章 编译系统设计
> 正所谓“麻雀虽小，五脏俱全”，本章从全局的角度描述了编译系统的基本结构，并按照编译、汇编和链接的流程来介绍其设计。

## 2.1 编译程序的设计
> 编译器是编译系统的核心，主要负责解析源程序的语义，生成目标机器代码。一般情况下，编译流程包含 ***`词法分析`***、***`语法分析`***、***`语义分析`*** 和 ***`代码生成`*** 四个阶段。***`符号表管理`*** 和 ***`错误处理`*** 贯穿于整个编译流程。***如果编译器支持代码优化，那么还需要优化器模块***。

> `图2-1 编译器结构`

### 2.1.1 词法分析
> 现在假定我们拥有一段使用C语言书写的源程序，词法分析器通过对源文件的扫描获得高级语言定义的 ***`词法记号`***。所谓词法记号（也称为 ***`终结符`***），反映在高级语言语法中就是对应的`标识符`、`关键字`、`常量`，以及`运算符`、`逗号`、`分号等界符`。见`图2-2`。

> `图2-2 词法分析功能`

> 例如语句： `var2=var1+100;` 该语句包含了6个词法记号，它们分别是：“var2”、“=”、“var1”、“+”、“100”和分号。

> 对词法分析器的要求是能正常识别出这些不同形式的词法记号。词法分析器的 ***输入是源代码文本文件内一长串的文本内容***，那么如何从文本串中分析出每个词法记号呢？为了解决这个问题，需要引入 ***`有限自动机`*** 的概念。
> 
> 有限自动机能解析并识别词法记号，比如 ***识别标识符的有限自动机、识别常量的有限自动机等***。有限自动机从开始状态启动，读入一个字符作为输入，并根据该字符选择进入下一个状态。继续读入新的字符，直到遇到结束状态为止，读入的所有字符序列便是有限自动机识别的词法记号。
> 
> `图2-3`描述了识别标识符的有限自动机。C语言标识符的定义是：一个不以数字开始的由下划线、数字、字母组成的非空字符串。图中的自动机从0号状态开始，读入一个下划线或者字母进入状态1，状态1可以接受任意数量的下划线、字母和数字，同时状态1也是结束状态，一旦它读入了其他异常字符便停止自动机的识别，这样就可以识别任意一个合法的标识符。如果在非结束状态读入了异常的字符，意味着发生了词法错误，自动机停止（当然，上述标识符的有限自动机不会出现错误的情况）。

> 使用有限自动机，可以识别出自定义语言包含的所有词法记号。***把这些词法记号记录下来，作为下一步语法分析的输入***。如果使用一遍编译方式，就不用记录这些词法记号，而是直接将识别的词法记号送入语法分析器进行处理。

### 2.1.2 语法分析
> ***`词法分析器`的输入是`文本字符串`，`语法分析器`的输入则是`词法分析器识别的词法记号序列`***。语法分析器的输出不再是一串线性符号序列，而是一种树形的数据结构，通常称之为 ***`抽象语法树`***。见`图2-4`。
>
> 图2-4 语法分析功能

> 继续前面赋值语句的例子，我们可以先看看它可能对应的抽象语法树，如`图2-5`所示。
> 
> 图2-5 抽象语法树示例

> 从`图2-5`中可以看出，***所有的`词法记号`都出现在树的`叶子节点`上***，我们称 ***这样的`叶子节点`为`终结符`***。而所有的`非叶子节点`，都是对一串词法记号的抽象概括，我们称之为 ***`非终结符`***，可以将非终结符看作一个单独的语法模块（***抽象语法子树***）。其实，***整个源程序是一棵完整的抽象语法树，它由一系列语法模块按照树结构组织起来***。`语法分析器`就是要 ***获得源程序的抽象语法树表示***，这样才能让编译器具体识别每个语法模块的含义，分析出程序的整体含义。
> 
> 在介绍语法分析器的工作之前，需要先获得 ***高级语言语法的形式化表示***，即 ***`文法`***。***`文法`定义了源程序代码的书写规则，同时也是`语法分析器`构造`抽象语法树`的规则***。如果要定义 ***赋值语句的文法***，一般可以表达成如下 ***`产生式`*** 的形式： ***`<赋值语句> => 标识符 等号 <表达式> 分号`***
> 
> 被“`< >`”括起来的内容表示`非终结符`，终结符直接书写即可，上式可以读作“赋值语句推导出标识符、等号、表达式和分号”。显然，***表达式也有相关的文法定义***。根据定义好的高级语言特性，可以设计出相应的高级语言的文法，使用文法可以准确地表达高级语言的语法规则。
> 
> 有了高级语言的`文法`表示，就可以构造`语法分析器`来生成`抽象语法树`。在编译原理教材中，描述了很多的文法分析算法，有自顶向下的`LL（1）分析`，也有自底向上的`算符优先分析`、`LR分析`等。其中最常使用的是`LL（1）`和`LR分析`。相比而言，`LR分析器`能力更强，但是分析器设计比较复杂，不适合手工构造。我们设计的高级语言文法，只要稍加约束便能使`LL（1）分析器`正常工作，因此本书采用`LL（1）分析器`来完成语法分析的工作。***`递归下降子程序`*** 作为`LL（1）算法`的一种便捷的实现方式，非常适合手工实现语法分析器。`递归下降子程序`的基本原则是：***将`产生式左侧的非终结符`转化为函数定义，将`产生式右侧的非终结符`转化为函数调用，将`终结符`转化为词法记号匹配***。

> 每次对子程序的调用，就是按照前序的方式对该抽象语法子树的一次构造。例如在构造赋值语句子树时，会先构造“赋值语句”根节点，然后依次匹配标识符、等号子节点。当遇到下一个非终结符时，会进入对应的“表达式”子程序内继续按照前序方式构造子树的子树。最后匹配当前子程序的最后一个子节点，完成“赋值语句”子树的构造。整个语法分析就是按照这样的方式构造“程序”树的一个过程，***一旦在终结符匹配过程中出现读入的词法记号与预期的词法记号不吻合的情况，便会产生语法错误***。

### 2.1.3 符号表管理
> 符号表是记录符号信息的数据结构，它使用按名存取的方式记录与符号相关的所有编译信息。编译器工作时，少不了符号信息的记录和更新。在本书定义的高级语言中，符号存在两种形式：变量和函数。前者是数据的符号化形式，后者是代码的符号化形式。***`语义分析`需要根据符号检测变量使用的合法性，`代码生成`需要根据符号产生正确的地址，因此，符号信息的准确和完整是进行语义分析和代码生成的前提***。见`图2-6`。

> 对于变量符号，需要在符号表中记录变量的名称、类型、区分变量的声明和定义的形式，如果变量是局部变量，还需要记录变量在运行时栈帧中的相对位置。

> 对于函数符号，需要在符号表中记录函数的名称、返回类型、参数列表，以及函数内定义的所有局部变量等。

> 由于局部变量的存在，符号表必须考虑代码作用域的变化。函数内的局部变量在函数之外是不可见的，因此在代码分析的过程中，符号表需要根据作用域的变化动态维护变量的可见性。

### 2.1.4 语义分析
> 编译原理教材中，***将语言的文法分为4种***：`0型`、`1型`、`2型`、`3型`，并且 ***这几类文法对语言的描述能力依次减弱***。其中，***`3型文法`也称为`正规文法`***，词法分析器中 ***`有限自动机`能处理的语言文法正是`3型文法`***。***`2型文法`也称为`上下文无关文法`***，也是 ***目前计算机程序语言所采用的文法***。顾名思义，程序语言的文法是上下文无关的，即程序代码语句之间在文法层次上是没有关联的。例如在分析赋值语句时，`LL（1）分析器`无法解决 ***“被赋值的对象是已经声明的标识符吗？”*** 这样的问题，因为 ***`语法分析`只关心程序语言语法形式的正确性，而不考虑语法模块上下文之间联系的合法性***。
> 
> 然而实际的情况是，程序语言的语句虽然 ***形式上是上下文无关的，但含义上却是上下文相关的***。例如：不允许使用一个未声明的变量，不允许函数实参列表和形参列表不一致，不允许对无法默认转换的类型进行赋值和运算，不允许continue语句出现在循环语句之外等，***这些要求是`语法分析器`不能完成的***。

> ***`语义分析`*** 是编译器处理流程中对源代码正确性的最后一次检查，只要源代码语义上没有问题，编译器就可以正常引导目标代码的生成。

>> //notes：所以，三个阶段能查出的错误的类型分别如下：
- `词法分析`能查出的错误的例子有：不正确的词法记号（or say，终结符），比如：
  * 在C语言中以数字开头的变量名。
  * 变量名中间出现了特殊符号。
- `语法分析`能查出的错误的例子有：非预期中的、不符合文法规则的词法记号（或者说抽象语法树中期待该出现某些类型的东西了，结果没出现，或者出现多了，或者出现的是别的类型的东西），比如：
  * 在C语言中，读到一个变量 `x`，一个等号 `=`，然后又读到一个加号 `+`，整个式子目前是 `x=+`： —— 虽然每个词法记号都是合法的，但是按C语言的语法规则，等号后面不可能出现加号。
  * 语句结尾没有分号。
  * 定义变量时没有类型。
- `语义分析`能查出的错误的例子有：
  * 未定义的变量就直接用了。
  * 超出作用范围的变量还在用。
  * 函数定义和调用不符合。
