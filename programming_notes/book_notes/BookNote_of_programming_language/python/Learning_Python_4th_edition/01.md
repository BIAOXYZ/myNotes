
# 前言

> 尽管只是同一种语言的不同版本，但Python 3.0几乎无法运行为之前版本编写的代码（单单print从语句修改为函数，听上去更合理，但是，它几乎影响到所有已经编写好的Python程序）。

# 第一部分 使用入门

# 第1章

> ***20世纪90年代中后期互联网带来的信息爆炸，使有限的程序员难以应付繁多的软件开发项目，往往要求开发者以互联网演变一样的速度去开发系统。时过境迁，后信息爆炸时代带来了公司裁员和经济衰退。今天，往往要求程序员以更少的人力去实现相同的开发任务。***无论在以上哪种背景下，Python作为开发工具均以付出更少的精力完成更多的任务而脱颖而出。

> 简而言之，目前Python的标准实现方式是将源代码的语句编译（或者说是转换）为字节码的形式，之后再将字节码解释出来。由于字节码是一种与平台无关的格式，字节码具有可移植性。然而，因为Python没有将代码编译成底层的二进制代码（例如，Intel芯片的指令），一些Python程序将会比像C这样的完全编译语言慢一些。

> Python标准的`pickle`模块提供了一个简单的对象持久化系统：它能够让程序轻松地将整个Python对象保存和恢复到文件和文件类的对象中。在网络上，同样可以找到名叫ZODB的第三方系统，它为Python脚本提供了完整的面向对象数据库系统，系统SQLObject可以将关系数据库映射至Python的类模块。并且，从Python 2.5版本开始，SQLite已经成为Python自带标准库的一部分了。

> Python开发者使用一个源代码控制系统在线协同地工作。修改遵从一个正式的PEP（Python Enhancement Proposal）协议并且必须经过Python的扩展回归测试系统。

> 一个非正式的组织PSF（Python Software Foundation，Python软件基金会），负责组织会议并处理知识产权的问题。

> 5.在Python中`import this`有什么意义？
>> 5.import this会触发Python内部的一个彩蛋，它将显示Python语言层面之下的设计哲学。下一章你将会学习如何使用这条命令。

> 当Python于20世纪90年代初期出现在软件舞台上时，曾经引发其拥护者和另一个受欢迎脚本语言Perl的拥护者之间的冲突，但现今已成为经典的争论。 <br> 故事是这样的：你可以用Python做到一切用Perl能做到的事，但是，做好之后，还可以阅读自己的程序代码。 <br> Perl程序代码很容易写，但是很难读。由于多数软件在最初的创建后都有较长的生命周期，所以很多人认为Python是一种更有效的工具。 <br> ***考虑一下：当人们在作画或雕塑时，他们是为自己做，为了纯粹美学考虑。其他人日后去修改图画或雕像的可能性很低。这是艺术和工程之间关键的差异。当人们在编写软件时，他们不是为自己写。***

# 第2章

> 迄今为止，我大多数时候都是将Python作为一门编程语言来介绍的。但是，从目前的实现上来讲，Python也是一个名为解释器的软件包。解释器是一种让其他程序运行起来的程序。当你编写了一段Python程序，Python解释器将读取程序，并按照其中的命令执行，得出结果。实际上，解释器是代码与机器的计算机硬件之间的软件逻辑层。

> 当Python包安装在机器上后，它包含了一些最小化的组件：一个解释器和支持的库。根据使用情况的不同，Python解释器可能采取可执行程序的形式，或是作为链接到另一个程序的一系列库。根据选用的Python版本的不同，解释器本身可以用C程序实现，或一些Java类实现，或者其他的形式。无论采取何种形式，编写的Python代码必须在解释器中运行。

> 当Python运行脚本时，在代码开始进行处理之前，Python还会执行一些步骤。确切地说，第一步是编译成所谓的“字节码”，之后将其转发到所谓的“虚拟机”中。

> 如果Python进程在机器上拥有写入权限，那么它将把程序的字节码保存为一个以`.pyc`为扩展名的文件（“.pyc”就是编译过的“.py”源代码）。当程序运行之后，你会在那些源代码的附近（也就是说同一个目录下）看到这些文件。

> 如果Python无法在机器上写入字节码，程序仍然可以工作：字节码将会在内存中生成并在程序结束时简单地丢弃。

> 一旦程序编译成字节码（或字节码从已经存在的.pyc文件中载入），之后的字节码发送到通常称为Python虚拟机（Python Virtual Machine，简写为`PVM`）上来执行。PVM听起来比它本身给人的印象更深刻一些。实际上，它不是一个独立的程序，不需要安装。事实上，PVM就是迭代运行字节码指令的一个大循环，一个接一个地完成操作。PVM是Python的运行引擎，它时常表现为Python系统的一部分，并且它是实际运行脚本的组件。从技术上讲，它才是所谓“Python解释器”的最后一步。

> 熟悉C和C++这类完全编译语言的读者或许已经发现了Python模式中的一些不同之处。其中一个是，在Python的工作中通常没有“build”或“make”的步骤：代码在写好之后立即运行。另外一个就是，Python字节码不是机器的二进制代码（例如，Intel芯片的指令）。字节码是特定于Python的一种表现形式。

> 这使开发周期大大缩短。在程序开始执行之前不需要预编译和连接；只需要简单地输入并运行代码即可。这同样使Python具有更多的动态语言特性：在运行时，Python程序去构建并执行另一个Python程序是有可能的，而且往往是非常方便的。例如，`eval`和`exec`内置模块，能够接受并运行包含Python程序代码的字符串。

> 事实上，在编写本书的过程中，Python语言有三种主要实现方式（`CPython`、`Jython`和`IronPython`）以及一些次要的实现方式，例如，Stackless Python。简要地说，CPython是标准的实现；其他的都是有特定的目标和角色的。所有的这些都用来实现Python语言，只是通过不同的形式执行程序而已。

> Python的第三种实现方式IronPython（比CPython和Jython都要新），其设计目的是让Python程序可以与Windows平台上的.NET框架以及与之对应的Linux的上开源的Mono编写成的应用相集成。 <br> 在实现上，IronPython很像Jython（实际上两者都是由同一个创始人开发的）。

> CPython、Jython和IronPython都是通过同样的方式实现Python语言的，即通过把源代码编译为字节码，然后在适合的虚拟机上执行这些字节码。然而，其他的系统，包括`Psyco`即时编译器以及`Shedskin C++`转换器，则试着优化了基本执行模块。这些系统并不是现阶段学习Python所必备知识，但是简要地了解这些执行模块可以帮助你更轻松地掌握这些模块。
