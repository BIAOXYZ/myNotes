
# 第3章 递归

## 基本递归

> 为了理解递归究竟是如何工作的，有必要先看看C语言中函数的执行方式。基于这点，我们需要了解一点关于C程序在内存中的组织方式。***基本上来说一个可执行程序由4个区域组成：`代码段`、`静态数据区`、`堆`与`栈`（见`图3-2a`）***。`代码段`包含程序运行时所执行的机器指令。`静态数据区`包含在程序生命周期内一直持久的数据，比如全局变量和静态局部变量。`堆`包含程序运行时动态分配的存储空间，比如用`malloc`分配的内存。`栈`包含函数调用的信息。按照惯例，***堆的增长方向为从程序低地址到高地址向上增长，而栈的增长方向刚好相反***（实际情况可能不是这样，与CPU的体系结构有关）。注意，这里用到的术语`堆`与第10章介绍的`数据结构堆`没有什么关系。

> 当C程序中调用了一个函数时，栈中会分配一块空间来保存与这个调用相关的信息。每一个调用都被当做是活跃的。***栈上的那块存储空间称为`活跃记录`，或者称为`栈帧`***。栈帧由5个区域组成：`输入参数`、`返回值空间`、`计算表达式时用到的临时存储空间`、`函数调用时保存的状态信息`以及`输出参数`（见`图3-2b`）。`输入参数`是传递到`活跃记录`中的参数；`输出参数`是传递给在`活跃记录`中调用的函数所使用的。一个活跃记录中的输出参数就成为栈中下一个活跃记录的输入参数。函数调用产生的活跃记录将一直存在于栈中直到这个函数调用结束。

> 回到示例3-1，考虑一下当计算4!时栈中都发生了些什么。初始调用fact会在栈中产生一个活跃记录，输入参数n=4（见图3-3，第1步）。由于这个调用没有满足函数的终止条件，因此fact将继续以n=3为参数递归调用。这将在栈上创建另一个活跃记录，但这次输入参数（见图3-3，第2步）。这里，n=3也是第一个活跃期中的输出参数，因为正是在第一个活跃期内调用fact产生了第二个活跃期。这个过程将一直继续，直到n的值变为1，此时满足终止条件，fact将返回1（见图3-3，第4步）。
>
> 一旦当n=1时的活跃期结束，n=2时的递归计算结果就是2×1=2，因而n=2时的活跃期也将结束，返回值为2（见图3-3，第5步）。结果就是n=3时的递归计算结果表示为3×2=6，因此n=3时的活跃期结束，返回值为6（见图3-3，第6步）。最终，当n=4时的递归计算结果将表示为6×4=24，n=4时的活跃期将结束，返回值为24（见图3-3，第7步）。此时，函数已经从最初的调用中返回，递归过程结束。

> 栈是用来存储函数调用信息的绝好方案，这正是由于其后进先出的特点（见第6章）精确满足了函数调用和返回的顺序。然而，使用栈也有一些缺点。栈维护了每个函数调用的信息直到函数返回后才释放，这需要占用相当大的空间，尤其是在程序中使用了许多递归调用的情况下。除此之外，因为有大量的信息需要保存和恢复，因此生成和销毁活跃记录需要耗费一定的时间。如此一来当函数调用的开销变得很大时，我们就需要考虑应该采用迭代的方案。幸运的是，我们可以采用一种称为尾递归的特殊递归方式来避免前面提到的这些缺点。
