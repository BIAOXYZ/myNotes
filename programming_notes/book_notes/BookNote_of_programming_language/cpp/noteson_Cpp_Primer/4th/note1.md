
# `#` 《C++ Primer》中文第四版

- C++ Primer 中文版（第 4 版） https://book.douban.com/subject/1767741/
- C++ Primer中文版 (第4版·特别版) https://book.douban.com/subject/4262575/
- C++Primer(英文版)(第4版) https://book.douban.com/subject/1900687/

:couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple:

# 第一章快速入门
## ~~1.1. 编写简单的 C++ 程序~~
## 1.2. 初窥输入/输出
### 1.2.2. 一个使用IO 库的程序
#### page 23
```c++
std::cout << "Enter two numbers:" << std::endl;

这个语句用了两次输出操作符。每个输出操作符实例都接受两个操作数：左
操作数必须是 ostream 对象；右操作数是要输出的值。操作符将其右操作数写
到作为其左操作数的 ostream 对象。

C++ 中，每个表达式都会产生一个结果，通常是将操作符作用到其操作数所
产生的值。当操作符是输出操作符时，结果是左操作数的值。也就是说，输出操
作返回的值是输出流本身。

既然输出操作符返回的是其左操作数，那么我们就可以将输出请求链接在一起。
```
```c++
endl 是一个特殊值，称为操纵符，将它写入输出流时，具有输出换行的效
果，并刷新与设备相关联的缓冲区。通过刷新缓冲区，用户可立即看到写入到
流中的输出。
```

#### page 24
```c++
标准库使用命名空间的副作用是，当我们使用标准库中的名字时，必须显式
地表达出使用的是命名空间 std 下的名字。std::cout 的写法使用了作用域操
作符（scope operator，:: 操作符），表示使用的是定义在命名空间 std 中的
cout。我们将在第 3.1 节学习到程序中经常使用的避免这种冗长句法的方法。
```
```c++
输入操作符（>> 操作符）行为与输出操作符相似。它接受一个 istream 对
象作为其左操作数，接受一个对象作为其右操作数，它从 istream 操作数读取
数据并保存到右操作数中。像输出操作符一样，输入操作符返回其左操作数作为
结果。由于输入操作符返回其左操作数，我们可以将输入请求序列合并成单个语
句。
```

## ~~1.3. 关于注释~~
## 1.4. 控制结构
### 1.4.4. 读入未知数目的输入
#### page 38
```c++
while (std::cin >> value)

这里所产生的是，为判断条件，先执行输入操作

std::cin >> value

它具有从标准输入读取下一个数并且将读入的值保存在 value 中的效果。
输入操作符（第 1.2.2 节）返回其左操作数。while 条件测试输入操作符的返
回结果，意味着测试 std::cin。

当我们使用 istream 对象作为条件，结果是测试流的状态。如果流是有效
的（也就是说，如果读入下一个输入是可能的）那么测试成功。遇到文件结束符
或遇到无效输入时，如读取了一个不是整数的值，则 istream 对象是无效的。
处于无效状态的 istream 对象将导致条件失败。
```

## 1.5. 类的简介
### 1.5.1. Sales_item 类
#### page 41
```c++
标准库的头文件用尖括号 < > 括起来，非标准库的头文件用双引号 " " 括起来。
```

## ~~1.6. C++ 程序~~

:couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple::couple:

# 第二章变量和基本类型
## 2.1. 基本内置类型
#### page 55
```c++
C++ 定义了一组表示整数、浮点数、单个字符和布尔值的算术类型，另外还
定义了一种称为 void 的特殊类型。
```
```c++
算术类型的存储空间依机器而定。这里的存储空间是指用来表示该类型的位
（bit）数。C++标准规定了每个算术类型的最小存储空间，但它并不阻止编译器
使用更大的存储空间。事实上，对于int 类型，几乎所有的编译器使用的存储空
间都比所要求的大。
```

### 2.1.1. 整型
#### page 56
```c++
表示整数、字符和布尔值的算术类型合称为整型。
```

#### page 57
```c++
虽然确切的大小因机器不同而不同，但是通常将 8 位的块作为一个字
节，32 位或 4 个字节作为一个“字（word）”。

大多数计算机将存储器中的每一个字节和一个称为地址的数关联起来。
对于一个 8 位字节和 32 位字的机器，我们可以将存储器的字表示如
下：
```

#### page 58
```c++
和其他整型不同，char 有三种不同的类型：plain char 、unsigned char 和
signed char。虽然 char 有三种不同的类型，但只有两种表示方式。可以使用
unsigned char 或 signed char 表示 char 类型。使用哪种 char 表示方式由
编译器而定。
```
```c++
C++ 标准并未定义 signed 类型如何用位来表示，而是由每个编译器自由决
定如何表示 signed 类型。这些表示方式会影响 signed 类型的取值范围。8 位
signed 类型的取值肯定至少是从 -127 到 127，但也有许多实现允许取值从
-128 到 127。
```
```c++
对象的类型决定对象的取值。这会引起一个疑问：当我们试着把一个超出其
取值范围的值赋给一个指定类型的对象时，结果会怎样呢？答案取决于这种类型
是 signed 还是 unsigned 的。

对于 unsigned 类型来说，编译器必须调整越界值使其满足要求。编译器会
将该值对 unsigned 类型的可能取值数目求模，然后取所得值。比如 8 位的
unsigned char，其取值范围从 0 到 255（包括 255）。如果赋给超出这个范围
的值，那么编译器将会取该值对 256 求模后的值。例如，如果试图将 336 存储
到 8 位的 unsigned char 中，则实际赋值为 80，因为 80 是 336 对 256 求
模后的值。

对于 unsigned 类型来说，负数总是超出其取值范围。unsigned 类型的对
象可能永远不会保存负数。有些语言中将负数赋给 unsigned 类型是非法的，但
在 C++ 中这是合法的。

C++ 中，把负值赋给 unsigned 对象是完全合法的，其结果是
该负数对该类型的取值个数求模后的值。所以，如果把 -1 赋
给8 位的 unsigned char，那么结果是 255，因为 255 是 -1 对
256 求模后的值。

当将超过取值范围的值赋给 signed 类型时，由编译器决定实际赋的值。在
实际操作中，很多的编译器处理 signed 类型的方式和 unsigned 类型类似。也
就是说，赋值时是取该值对该类型取值数目求模后的值。然而我们不能保证编译
器都会这样处理 signed 类型。
```

### 2.1.2. 浮点型
#### page 59
```c++
对于实际的程序来说，float 类型精度通常是不够的——float 型只能
保证 6 位有效数字，而 double 型至少可以保证 10 位有效数字，能
满足大多数计算的需要。
```

#### page 60
```c++
整型运算时，用 32 位表示 int 类型和用 64 位表示 long 类型的
机器会出现应该选择 int 类型还是 long 类型的难题。在这些机器上，
用 long 类型进行计算所付出的运行时代价远远高于用 int 类型进行
同样计算的代价，所以选择类型前要先了解程序的细节并且比较 long
类型与 int 类型的实际运行时性能代价。

决定使用哪种浮点型就容易多了：使用 double 类型基本上不会有错。
在 float 类型中隐式的精度损失是不能忽视的，而 double 类型精度代
价相对于 float 类型精度代价可以忽略。事实上，有些机器上，double
类型比 float 类型的计算要快得多。long double 类型提供的精度通常
没有必要，而且还需要承担额外的运行代价。
```

## 2.2. 字面值常量
#### page 62
```c++
定义长整型时，应该使用大写字母 L。小写字母 l 很容易
和数值 1 混淆。

类似地，可通过在数值后面加 U 或 u 定义 unsigned 类型。同时加 L 和 U
就能够得到 unsigned long 类型的字面值常量。但其后缀不能有空格：
128u /* unsigned */     1024UL /* unsigned long */
1L   /* long */         8Lu /* unsigned long */

没有 short 类型的字面值常量。
```

#### page 63
```c++
这些字面值都是 char 类型的。在字符字面值前加 L 就能够得到 wchar_t
类型的宽字符字面值。如：
L'a'
```

#### page 64
```c++
两个相邻的仅由空格、制表符或换行符分开的字符串字面值（或宽字符串字
面值），可连接成一个新字符串字面值。这使得多行书写长字符串字面值变得简
单：
```

#### page 66
```c++
注意反斜线符号必须是该行的尾字符——不允许有注释或空格符。同样，后
继行行首的任何空格和制表符都是字符串字面值的一部分。正因如此，长字符串
字面值的后继行才不会有正常的缩进。
```
```c++
建议：不要依赖未定义行为

使用了未定义行为的程序都是错误的，即使程序能够运行，也只是巧合。
未定义行为源于编译器不能检测到的程序错误或太麻烦以至无法检测的
错误。
```

## 2.3. 变量
#### page 69
```c++
关键概念：强静态类型

C++ 是一门静态类型语言，在编译时会作类型检查。

在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类
型不支持某种操作，那么这种类型的对象也就不能执行该操作。

在 C++ 中，操作是否合法是在编译时检查的。当编写表达式时，编译器
检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不
是的话，那么编译器会提示错误，而不产生可执行文件。

随着程序和使用的类型变得越来越复杂，我们将看到静态类型检查能帮
助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的
每个实体的类型。因此，程序中使用变量前必须先定义变量的类型。
```

### 2.3.1. 什么是变量
#### page 69
```c++
变量提供了程序可以操作的有名字的存储区。C++ 中的每一个变量都有特定
的类型，该类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值
范围以及可应用在该变量上的操作集。
```
```c++
我们在第五章再详细探讨表达式，现在先介绍 C++ 的两种表达式：
1. 左值（发音为 ell-value）：左值可以出现在赋值语句的左边或右边。
2. 右值（发音为 are-value）：右值只能出现在赋值的右边，不能出现在赋
值语句的左边。

变量是左值，因此可以出现在赋值语句的左边。数字字面值是右值，因此
不能被赋值。
```

#### page 70
```c++
在本书中，我们将看到在许多情形中左值或右值的使用影响程
序的操作和/或性能——特别是在向函数传递值或从函数中返
回值的时候。
```

### 2.3.3. 定义对象
#### page 74
```c++
C++ 支持两种初始化变量的形式：复制初始化和直接初始化。
复制初始化语法用等号（=），直接初始化则是把初始化
式放在括号中：
int ival(1024); // direct-initialization
int ival = 1024; // copy-initialization

虽然在本书到目前为止还没有清楚说明，但是在 C++ 中理解
“初始化不是赋值”是必要的。初始化指创建变量并给它赋初
始值，而赋值则是擦除对象的当前值并用新值代替。
```
```c++
当初始化类类型对象时，复制初始化和直接初始化之间的差别
是很微妙的。我们在第十三章再详细解释它们之间的差别。现
在我们只需知道，直接初始化语法更灵活且效率更高。
```

#### page 75
```c++
初始化内置类型的对象只有一种方法：提供一个值，并且把这个值复制到新
定义的对象中。对内置类型来说，复制初始化和直接初始化几乎没有差别。

对类类型的对象来说，有些初始化仅能用直接初始化完成。要想理解其中缘
由，需要初步了解类是如何控制初始化的。
```
```c++
定义如何进行初始化的成员函数称为构造函数。和
其他函数一样，构造函数能接受多个参数。一个类可以定义几个构造函数，每个
构造函数必须接受不同数目或者不同类型的参数。
```
```c++
也可以通过一个计数器和一个字符初始化string 对象。这样创建的对象包
含重复多次的指定字符，重复次数由计数器指定：

std::string all_nines(10, '9'); // all_nines= "9999999999"

本例中，初始化 all_nines 的唯一方法是直接初始化。有多个初始化式时
不能使用复制初始化。
```

### 2.3.4. 变量初始化规则
#### page 77
```c++
内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变
量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化。除了用作
赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。未初
始化变量引起的错误难于发现。正如我们在第 2.2 节劝告的，永远不要依赖未
定义行为。
```

#### page xx
```c++

```


#### page xx
```c++

```
