
# OJ's

算法珠玑——一个最精简的题库 https://www.gitbook.com/book/soulmachine/algorithm-essentials/details

《剑指Offer》第二版源代码 https://github.com/zhedahht/CodingInterviewChinese2

BAT机器学习面试1000题系列 https://github.com/julycoding/BAT-ML-1000
> BAT机器学习面试1000题系列（第1~305题） https://blog.csdn.net/v_july_v/article/details/78121924
>> 七月在线 - 面试题库 https://www.julyedu.com/question/

LeetCode题解{from Apachecn} https://github.com/apachecn/awesome-leetcode
- 推荐 LeetCode 网站
  * VISUALGO https://visualgo.net/
  * 【小姐姐】刷题博客 https://www.liuchuo.net/
    - 浙大pat考试的难度和acm竞赛水平能否对应？ - 知乎 https://www.zhihu.com/question/29369723
    - PAT(Programming Ability Test)练兵场 https://www.nowcoder.com/pat

The Algorithms https://github.com/TheAlgorithms/
- https://github.com/TheAlgorithms/Python || 热榜第一！GitHub 标星 5.6w，如何用 Python 实现所有算法？ https://mp.weixin.qq.com/s/7ZUrfvfb3u3e6wxFQBt7uQ
- https://github.com/TheAlgorithms/C
- https://github.com/TheAlgorithms/C-Plus-Plus

2018/2019/校招/春招/秋招/算法/机器学习(Machine Learning)/深度学习(Deep Learning)/自然语言处理(NLP)/C/C++/Python/面试笔记 https://github.com/imhuay/Algorithm_Interview_Notes-Chinese

Wiki for OI / ACM-ICPC. （某大型游戏线上攻略，内含炫酷算术魔法） https://oi-wiki.org https://github.com/24OI/OI-wiki

《挑战程序设计竞赛》习题册攻略 https://github.com/yogykwan/acm-challenge-workbook

--------------------------------------------------

后端架构师技术图谱 https://github.com/xingshaocheng/architect-awesome

技术和架构等相关文档 https://github.com/xunchangguo/km
- 技术文档中文版本：http://doczh.cn/

Learn X in Y minutes https://learnxinyminutes.com/

:u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272:

# Online IDE/Platform

- c9.io https://aws.amazon.com/cloud9/
> c9.io是可以反向推送到github相应的仓库的，但是我懒得试了实在是，这个帖子里有方法，记录一下就好：
>> Push to github from cloud9 https://gist.github.com/jboulhous/6007980
- Koding https://koding.com/

在不到30s内得到一个干净的开箱即用的临时linux系统. https://github.com/super-inspire/super-inspire-end
> Super Inspire http://60.190.81.133:8888/

***Linux Lab***：
- 十大使用 Linux Lab 的理由：内核和嵌入式开发 https://www.ithome.com/0/464/333.htm
  * Linux Lab: Linux 内核实验环境 https://tinylab.org/linux-lab/
- 免费玩转，Linux Lab 全面支持龙芯开发环境 https://www.ithome.com/0/505/022.htm
  * > ▶项目主页：http://tinylab.org/linux-lab
  * > ▶代码仓库：https://gitee.com/tinylab/linux-lab

Awesome Online IDE: 🌩️ A list of awesome online development environments https://github.com/styfle/awesome-online-ide
- > **Snippets**
  * [Ideone](https://ideone.com/) - Run snippets from over 60 languages including AWK, Swift, and SQLite.
  * [CPP Shell](http://cpp.sh/) - Run C++ snippets with input flags for warning level and optimization level.

一个基于浏览器的编程工具 (Coderlane) https://www.v2ex.com/t/620951
> 创造最完美的在线实时结对编程环境 https://coderlane.net/

【[:star:][`*`]】【一个日本的在线ide，提供很多种语言支持，关键画风很萌(●'◡'●)。参考下面那个改程序错误的链接，里面虚构了一个叫Noda的二次元萌妹子(❤ ω ❤)】 Paiza.io -- Just write and run code online ! https://paiza.io/en
- > This is an easy task - just fix the code written by a new lady programmer!｜paiza’s online hackathon Vol.1 https://paiza.jp/poh/ec-campaign
>> notes: 图快的话可以直接用类似下面形式的网址：
- https://paiza.io/en/projects/new?language=c
- https://paiza.io/en/languages/online-cpp-compiler
  * https://paiza.io/en/projects/new?language=cpp
- https://paiza.io/en/projects/new?language=python
- https://paiza.io/en/languages/mysql
  * https://paiza.io/en/projects/new?language=mysql
- https://paiza.io/en/languages/bash

repl.it Languages https://repl.it/languages
- https://repl.it/languages/python
- https://repl.it/languages/python3
- https://repl.it/languages/cpp

Free Online IDE and Terminal - Tutorialspoint https://www.tutorialspoint.com/codingground.htm
- Execute Python Online (Python v2.7.13) https://www.tutorialspoint.com/execute_python_online.php
- Execute Python-3 Online (Python v3.6.2) https://www.tutorialspoint.com/execute_python3_online.php
- Compile and Execute C Online (GNU GCC v7.1.1) https://www.tutorialspoint.com/compile_c_online.php
- Compile and Execute C++ Online (GNU GCC v7.1.1) https://www.tutorialspoint.com/compile_cpp_online.php
- Compile and Execute C++11 Online (GNU GCC v7.1.1) https://www.tutorialspoint.com/compile_cpp11_online.php

OnlineGDB https://www.onlinegdb.com/
- > If you are new to debugging a program, then it will be helpful to get to know the usage of debugger. You can go through [this guide](https://www.onlinegdb.com/blog/brief-guide-on-how-to-use-onlinegdb-debugger/) on how to use debugger.
  * > You can set breakpoint via GDB console as well, more details you can find on [this article](http://www.gdbtutorial.com/tutorial/how-use-gdb-example).
- https://www.onlinegdb.com/online_python_compiler
- https://www.onlinegdb.com/online_c_compiler

Compiler Explorer https://github.com/compiler-explorer/compiler-explorer || https://godbolt.org/  【业界良心，除了C/C++，支持很多其他语言；在线就能用编译器和看汇编。】

OneCompiler https://onecompiler.com/ || https://github.com/onecompiler
- PostgreSQL online editor https://onecompiler.com/postgresql/
- C++ Online Compiler https://onecompiler.com/cpp
- Python Online Compiler
  * https://onecompiler.com/python2
  * https://onecompiler.com/python

**Golang类**：
- The Go Playground https://play.golang.org/
- The Go Play Space https://goplay.space/

**C/C++类**：
- http://cpp.sh/ 【这个是 www.cplusplus.com 官方示例里用的】

## 未用过或不常用Online IDE/Platform

Codiad http://codiad.com/

CODENVY https://codenvy.com/

Eclipse Che https://www.eclipse.org/che/

https://www.heroku.com/postgres

Mozilla 释出在线 IDE：WebAssembly Studio 测试版 - Mozilla - cnBeta.COM
https://www.cnbeta.com/articles/soft/717311.htm
> https://webassembly.studio/

轻松搞定IPython + Notebook 基于云的科学计算环境
https://www.jianshu.com/p/e758e00f24ef

畅享云时代：开发者必备的8个最佳云端集成开发环境
http://www.cnblogs.com/lhb25/archive/2012/11/20/cloud-ide-for-developers.html

微软上线Try .NET，支持在浏览器运行C#代码 https://www.ithome.com/0/405/369.htm

## 可作为插件的online ide

RunMyCode https://runmycode.online/
> 这里可以直接在github上执行代码，美滋滋。

## online ide for special languages

【Python官方的】 https://www.python.org/shell/

【programiz.com这个好像只有python3】 Python Online Compiler https://www.programiz.com/python-programming/online-compiler/
>> //notes：呃，准确说应该是python语言只有python3，别的语言竟然还有。但是它没有一个比较好找的入口，所以就不放到前面了。比如C语言的是：https://www.programiz.com/c-programming/online-compiler/

:u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272:

# Code Learning Website 

程序猿必须知道的一些有用的（外国）网站 https://mp.weixin.qq.com/s/236sO6EKvctQrga2Zs5JMg || 学习 CS 时必须知道的一些有用的网站 https://www.oschina.net/translate/best-websites-a-programmer-should-visit
- :link: Some useful websites for programmers. https://github.com/sdmg15/Best-websites-a-programmer-should-visit

Calmcode -- Code. Simply. Clearly. Calmly. https://calmcode.io/

## freeCodeCamp

https://www.freecodecamp.cn/about
- 中文站 https://www.freecodecamp.cn/
- 英文站 https://www.freecodecamp.org/
- 使用 freeCodeCamp 编程 是一番怎样的体验？ - 知乎 https://www.zhihu.com/question/46711186

Interactive Tutorials https://github.com/ronreiter/interactive-tutorials
- http://www.learnjavaonline.org/
- https://www.learn-c.org/
- https://www.learnpython.org/

freeCodeCamp Guide https://guide.freecodecamp.org/

## (Programiz)[https://www.programiz.com/]

- https://www.programiz.com/python-programming
- https://www.programiz.com/c-programming
  * https://www.programiz.com/c-programming/examples
- https://www.programiz.com/cpp-programming

Programiz的在线编译器：
- C++ Online Compiler https://www.programiz.com/cpp-programming/online-compiler/
- C Online Compiler https://www.programiz.com/c-programming/online-compiler/
- Python Online Compiler https://www.programiz.com/python-programming/online-compiler/

## HackerRank

- https://www.hackerrank.com/domains/python
- https://www.hackerrank.com/domains/cpp
- https://www.hackerrank.com/domains/sql
- https://www.hackerrank.com/domains/databases
- https://www.hackerrank.com/domains/mathematics
- https://www.hackerrank.com/domains/shell
- https://www.hackerrank.com/domains/algorithms
- https://www.hackerrank.com/domains/data-structures

## Online Games or Others

学习编程太枯燥？12款助你学编程的免费游戏 - 慕课网的文章 - 知乎 https://zhuanlan.zhihu.com/p/33783827
- CodinGame https://www.codingame.com/
- Code Combat https://codecombat.com/
- Check iO https://checkio.org/

2018 编程挑战网页 Top 10 - KenChoi的文章 - 知乎
http://zhuanlan.zhihu.com/p/32965070

今天开始你的技术生涯：40 个在线学习编程的工具 - KenChoi的文章 - 知乎
http://zhuanlan.zhihu.com/p/34280674

日本TI求职网站上线编程游戏：陪二次元妹纸用编程拯救世界 https://hot.cnbeta.com/articles/funny/811479
> 评论：https://paiza.jp/botchi 在这里

你以为我在玩游戏？其实我在学编程！ https://mp.weixin.qq.com/s/2njySI6EgW1MyQR0Cu6ELg

## programming visualization

VISUALGO https://visualgo.net/

:fireworks: Interactive Online Platform that Visualizes Algorithms from Code https://algorithm-visualizer.org/ || https://github.com/algorithm-visualizer/algorithm-visualizer

Data Structure Visualizations https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

OnlinePythonTutor -- Visualize Python, Java, JavaScript, TypeScript, Ruby, C, and C++ code execution in your Web browser http://pythontutor.com || https://github.com/pgbovine/OnlinePythonTutor

:u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272:

# Linux Programming

Difference between 'Killed' and 'Terminated' https://stackoverflow.com/questions/19206124/difference-between-killed-and-terminated
> 正常终止的程序会有clean exit来做些收尾工作，比如把仍在内存中的信息持久化。

## makefile and compilation

GNU make https://www.gnu.org/software/make/manual/html_node/index.html

跟我一起写Makefile https://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile

Make 命令教程 http://www.ruanyifeng.com/blog/2015/02/make.html

make makefile cmake qmake都是什么，有什么区别？ - 知乎 https://www.zhihu.com/question/27455963

换个角度说makefile - 守望的文章 - 知乎 https://zhuanlan.zhihu.com/p/100964932

Makefile由浅入深--教程、干货 - 剑神一笑的文章 - 知乎 https://zhuanlan.zhihu.com/p/47390641

【原来如此】为什么很多应用都安装在/usr/local目录下? - CSDN博客 https://blog.csdn.net/maray/article/details/9737549
  > https://www.gnu.org/software/automake/manual/html_node/Standard-Directory-Variables.html#Standard-Directory-Variables

Difference between “make install” and “sudo make install” https://unix.stackexchange.com/questions/20953/difference-between-make-install-and-sudo-make-install
> "So, if you are getting permission errors with make install, check and see whether you are trying to install into system directories, and install into /usr/local or similar instead. /usr/local is reserved for local installations. You may need to give yourself permission to write to /usr/local, but this is usually easily done. On Debian this can be done by adding yourself to the staff group. Better still, find or create a binary package, and install that instead. That way you can easily keep track of installed packages and obtain the other benefits of package management."

why “make” before “make install” https://stackoverflow.com/questions/16637860/why-make-before-make-install

What does 'make install' do? https://superuser.com/questions/360178/what-does-make-install-do
> "When you do "make install", the make program takes the binaries from the previous step and copies them into some appropriate locations so that they can be accessed. Unlike on Windows, installation just requires copying some libraries and executables and there is no registry requirement as such. In short, "make install" just copies compiled files into appropriate locations."

### --prefix

What does --prefix do exactly when used in ./configure? https://askubuntu.com/questions/891835/what-does-prefix-do-exactly-when-used-in-configure
> When you run `./configure`, the `--prefix` option lets you specify where those directories are. It is called `--prefix` because it lets you give the prefix that appears in the paths to each of the directories where files from the program or library that you are building are to be installed. Most `configure` scripts support `--prefix`, and omitting it and just running `./configure` is typically equivalent to `./configure --prefix=/usr/local`.

## 动态链接库相关

- linux找不到动态链接库 .so文件的解决方法 https://blog.csdn.net/gx19862005/article/details/48528235
- 无root权限下解决编译时的依赖问题 https://www.jianshu.com/p/da92ca36a220
- linux下静态/动态函数库的原理和编写 https://www.jianshu.com/p/695d16a8947f
  * Linux动态链接库.so文件的创建与使用 https://blog.csdn.net/ithomer/article/details/7346146
- /etc/ld.so.conf详解 http://www.cnblogs.com/chris-cp/p/3591306.html	

### 链接库之二

Linux共享库、静态库、动态库详解 https://www.cnblogs.com/sunsky303/p/7731911.html [`*`][:star:]

Linux 共享库指南 http://liaoph.com/linux-shared-libary/

Linux gcc编译生成静态库和共享动态库的过程 https://typecodes.com/cseries/gccgensharedlib.html

Linux下编写简单的动态链接库Linux下编写简单的动态链接库 https://www.cnblogs.com/floatedclouds/archive/2011/10/24/2222412.html

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## Troubleshooters.com

```Linux Library -> Linux Programming -> Bash/shellscript```
- http://troubleshooters.com/codecorn/shellscript/index.htm
- http://troubleshooters.com/linux/xargs.htm

```Linux Library -> Linux Programming -> C and C++```
- http://troubleshooters.com/codecorn/sockets/index.htm

## Code Corner http://troubleshooters.com/codecorn/index.htm

http://troubleshooters.com/codecorn/awk/index.htm

## 伯乐在线

简明解释算法中的大O符号 http://blog.jobbole.com/55184/

堆和堆的应用：堆排序和优先队列 http://blog.jobbole.com/113552/

:u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272:

# 编程知识

## 非技术类（or技术性不强类）编程知识

微服务部署：蓝绿部署、滚动部署、灰度发布、金丝雀发布 https://www.jianshu.com/p/022685baba7d

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 编程规范

Uber开放公司内部《Go语言风格指南》 https://www.ithome.com/0/450/227.htm
> https://github.com/uber-go/guide/blob/master/style.md

Shell Style Guide https://google.github.io/styleguide/shell.xml

Google 开源项目风格指南 (中文版) https://zh-google-styleguide.readthedocs.io/en/latest/ || https://github.com/zh-google-styleguide/zh-google-styleguide

Microsoft REST API Guidelines https://github.com/microsoft/api-guidelines

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

随笔分类 - UNIX环境高级编程学习笔记
https://www.cnblogs.com/lienhua34/category/607035.html

弱类型、强类型、动态类型、静态类型语言的区别是什么？ - 知乎
https://www.zhihu.com/question/19918532

what is the difference between function declaration and signature? https://stackoverflow.com/questions/2322736/what-is-the-difference-between-function-declaration-and-signature
> A function declaration is the prototype for a function (or it can come from the function definition if no prototype has been seen by the compiler at that point) - it includes the return type, the name of the function and the types of the parameters (optionally in C).
>
> A function signature is the parts of the function declaration that the compiler uses to perform overload resolution. Since multiple functions might have the same name (ie., they're overloaded), the compiler needs a way to determine which of several possible functions with a particular name a function call should resolve to. The signature is what the compiler considers in that overload resolution. 
> 
> Note that the return type is not part of the function signature. As the standard says in a footnote, "Function signatures do not include return type, because that does not participate in overload resolution".

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 堆，栈等

堆栈、堆、队列的区别 http://bbs.csdn.net/topics/290054298

What is the difference between the stack and the heap? https://www.quora.com/What-is-the-difference-between-the-stack-and-the-heap
- Differences between Stack and Heap http://net-informations.com/faq/net/stack-heap.htm
  * > Stack is used for static memory allocation and Heap for dynamic memory allocation, both stored in the computer's RAM .
  * > Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and it's allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer.
  * > Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory . Element of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.
  * > You can use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.	You can use heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.
  * > In a multi-threaded situation each thread will have its own completely independent stack but they will share the heap. Stack is thread specific and Heap is application specific. The stack is important to consider in exception handling and thread executions.

What and where are the stack and heap? https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap

Is accessing data in the heap faster than from the stack? https://stackoverflow.com/questions/24057331/is-accessing-data-in-the-heap-faster-than-from-the-stack 

Stack vs. Heap: Understanding Java Memory Allocation https://dzone.com/articles/stack-vs-heap-understanding-java-memory-allocation

CBootCamp 7. Memory : Stack vs Heap https://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html

## MMAP

Memory-mapped file https://en.wikipedia.org/wiki/Memory-mapped_file

内存映射服务的列表 https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.genprogc/ls_mem_mapping_srvcs.htm

认真分析mmap：是什么 为什么 怎么用 https://www.cnblogs.com/huxiao-tee/p/4660352.html || https://cloud.tencent.com/developer/article/1354167
- > **`mmap`基础概念**
  * > `mmap`是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，***<ins>而系统会自动回写脏页面到对应的文件磁盘上</ins>***，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：
    >> 【[:star:][`*`]】 //notes：所以`Andy Pavlo`的CMU数据库课程里提到数据库必须自己管理这一套，而不能用 `mmap`（否则看起来连最基本的 WAL 都做不到，因为你刚改完 page，还没改 log 呢，结果 `mmap` 机制直接把脏页给你落盘了。。。）。

操作系统：图文详解 内存映射 https://www.jianshu.com/p/719fc4758813

Linux 中 mmap() 函数的内存映射问题理解？ - 知乎 https://www.zhihu.com/question/48161206

阿里二面：什么是mmap？ - 艾小仙的文章 - 知乎 https://zhuanlan.zhihu.com/p/357820303

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## OOP programming

### Ioc & DI

- 透彻理解IoC(控制反转) https://blog.csdn.net/u014563989/article/details/55188673
- 深入理解DIP、IoC、DI以及IoC容器 https://www.cnblogs.com/liuhaorain/p/3747470.html

### 浅拷贝、深拷贝

Python 直接赋值、浅拷贝和深度拷贝解析 http://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html

Copy List with Random Pointer 深度拷贝，浅度拷贝，Lazy拷贝解析 https://blog.csdn.net/shoulinjun/article/details/18730871

Object copying https://en.wikipedia.org/wiki/Object_copying

如何理解 C++ 中的深拷贝和浅拷贝？ - 知乎 https://www.zhihu.com/question/36370072

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 不太技术性编程知识

史上最难编程的软件是什么？ - 园长的文章 - 知乎
http://zhuanlan.zhihu.com/p/35057341
> 阿波罗 11 号火箭制导系统代码 https://github.com/chrislgarry/Apollo-11

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 反射

反射 (计算机科学) https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6) || Reflection (computer programming) https://en.wikipedia.org/wiki/Reflection_(computer_programming)
- > 引入的动机
- > 下列代码片段创建类 Foo 的一个实例 foo，并调用它的方法 PrintHello。对于每个编程语言，展示平常的和基于反射的调用序列。
  * > **Go**
    ```go
    import "reflect"
    
    // Without reflection
    f := Foo{}
    f.Hello()
    
    // With reflection
    fT := reflect.TypeOf(Foo{})
    fV := reflect.New(fT)
    
    m := fV.MethodByName("Hello")
    if m.IsValid() {
        m.Call(nil)
    }
    ```
  * > **Python**
    ```py
    # Without reflection
    obj = Foo()
    obj.hello()
    
    # With reflection
    obj = globals()['Foo']() # globals() Return a dictionary representing the current global symbol table. 
    getattr(obj, 'hello')()  # getattr(object, name) Return the value of the named attribute of object.  
    
    # With eval
    eval('Foo().hello()')
    ```

为什么语言里要提供“反射”功能？ - 知乎 https://www.zhihu.com/question/28570203

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## RPC

谁能用通俗的语言解释一下什么是 RPC 框架？ - 洪春涛的回答 - 知乎 https://www.zhihu.com/question/25536695/answer/221638079
- > **本地过程调用**
  * > RPC就是要像调用本地的函数一样去调远程函数。在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算lvalue * rvalue的结果:
    ```
    1 int Multiply(int l, int r) {
    2    int y = l * r;
    3    return y;
    4 }
    5 
    6 int lvalue = 10;
    7 int rvalue = 20;
    8 int l_times_r = Multiply(lvalue, rvalue);
    ```
  * > 那么在第8行时，我们实际上执行了以下操作：
    ```
    1.将 lvalue 和 rvalue 的值压栈
    2.进入Multiply函数，取出栈中的值10 和 20，将其赋予 l 和 r
    3.执行第2行代码，计算 l * r ，并将结果存在 y
    4.将 y 的值压栈，然后从Multiply返回
    5.第8行，从栈中取出返回值 200 ，并赋值给 l_times_r
    ```
- > **远程过程调用带来的新问题**
  * > 在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：
  * > 1.**Call ID映射**。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。
  * > 2.**序列化和反序列化**。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。
  * > 3.**网络传输**。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。

既然有 HTTP 请求，为什么还要用 RPC 调用？ - 知乎 https://www.zhihu.com/question/41609070

如何给老婆解释什么是RPC - 柳树的文章 - 知乎 https://zhuanlan.zhihu.com/p/36427583

【from `小白debug`】 既然有 HTTP 协议，为什么还要有 RPC https://www.ithome.com/0/641/957.htm || https://mp.weixin.qq.com/s/0QWxFylodn7T6nvcS6HsDg

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 序列化和反序列化

序列化和反序列化 https://www.infoq.cn/article/serialization-and-deserialization

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## JIT(Just-in-time compilation) 即时编译

JIT编译的结果能不能cache起来，下次直接利用呢？ - RednaxelaFX的回答 - 知乎
https://www.zhihu.com/question/54984557/answer/142045332

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 字节对齐

<< Data structure alignment >>
https://en.wikipedia.org/wiki/Data_structure_alignment

- <<数据对齐详解>> https://www.cnblogs.com/bakari/archive/2012/08/27/2658956.html
- <<>> http://blog.csdn.net/hemengsi123/article/details/49814881
- <<>> https://www.cnblogs.com/Qwells/p/5750350.html
- <<>> http://blog.csdn.net/Microsues/article/details/6140329
- <<>> https://yq.aliyun.com/articles/10508

- <<>> http://www.jb51.net/article/36726.htm
- <<>> http://www.alongsky.com/?p=578

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 信号量

https://www.zhihu.com/question/47411729

## 锁

自旋锁spinlock剖析与改进
https://kb.cnblogs.com/page/105657/

Pthreads并行编程之spin lock与mutex性能对比分析
http://www.parallellabs.com/2010/01/31/pthreads-programming-spin-lock-vs-mutex-performance-analysis/

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 多进程多线程编程

Linux下的多线程编程和fork()函数详解
http://www.jb51.net/LINUXjishu/597423.html

父进程，子进程，线程之间的关系 - CSDN博客
https://blog.csdn.net/wang664626482/article/details/52523303

多线程 ---并发与并行概念总结 https://blog.csdn.net/qq_33290787/article/details/51790605
- 多线程有什么用？ - 知乎 https://www.zhihu.com/question/19901763
  * 多线程有什么用？ - pansz的回答 - 知乎 https://www.zhihu.com/question/19901763/answer/13299543
  > 1。对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。2。对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。
  >
  > 补充：有人对这个开桌子的开销很有兴趣。我把这个问题推广说开一下。开桌子的意思是指创建进程。开销这里主要指的是时间开销。可以做个实验：创建一个进程，在进程中往内存写若干数据，然后读出该数据，然后退出。此过程重复 1000 次，相当于创建/销毁进程 1000 次。在我机器上的测试结果是：       UbuntuLinux：耗时 0.8 秒       Windows7：耗时 79.8 秒        两者开销大约相差一百倍。这意味着，在 Windows 中，进程创建的开销不容忽视。换句话说就是，Windows 编程中不建议你创建进程，如果你的程序架构需要大量创建进程，那么最好是切换到 Linux 系统。大量创建进程的典型例子有两个，一个是 gnu autotools 工具链，用于编译很多开源代码的，他们在 Windows 下编译速度会很慢，因此软件开发人员最好是避免使用 Windows。另一个是服务器，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在 Windows 下运行的效率就会很差。这"可能"也是放眼全世界范围，Linux  服务器远远多于 Windows 服务器的原因。
  >
  > 再次补充：如果你是写服务器端应用的，其实在现在的网络服务模型下，开桌子的开销是可以忽略不计的，因为现在一般流行的是按照 CPU 核心数量开进程或者线程，开完之后在数量上一直保持，进程与线程内部使用协程或者异步通信来处理多个并发连接，因而开进程与开线程的开销可以忽略了。另外一种新的开销被提上日程：核心切换开销。现代的体系，一般 CPU 会有多个核心，而多个核心可以同时运行多个不同的线程或者进程。当每个 CPU 核心运行一个进程的时候，由于每个进程的资源都独立，所以 CPU 核心之间切换的时候无需考虑上下文。当每个 CPU 核心运行一个线程的时候，由于每个线程需要共享资源，所以这些资源必须从 CPU 的一个核心被复制到另外一个核心，才能继续运算，这占用了额外的开销。换句话说，在 CPU 为多核的情况下，多线程在性能上不如多进程。因而，当前面向多核的服务器端编程中，需要习惯多进程而非多线程。

为什么 MySQL 使用多线程，而 Oracle 和 PostgreSQL 使用多进程？ - 知乎 https://www.zhihu.com/question/20303558
- 为什么 MySQL 使用多线程，而 Oracle 和 PostgreSQL 使用多进程？ - 哼哈二匠的回答 - 知乎 https://www.zhihu.com/question/20303558/answer/14683235
- 为什么 MySQL 使用多线程，而 Oracle 和 PostgreSQL 使用多进程？ - 方圆的回答 - 知乎 https://www.zhihu.com/question/20303558/answer/14682076

进程间通信和线程间通信的几种方式 https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html
- > **进程、线程共同点**
  * > 它们都能提高程序的并发度，提高程序运行效率和响应时间。线程和进程在使用上各有优缺点。 线程执行开销比较小，但不利于资源的管理和保护，而进程相反。同时，***线程适合在SMP机器上运行，而进程可以跨机器迁移***。
- > **通信方式之间的差异**
  * > 因为那个根本原因，实际上只有进程间需要通信,同一进程的线程共享地址空间,没有通信的必要，但要做好同步/互斥,保护共享的全局变量。
  * > 而进程间通信无论是信号，管道pipe还是共享内存都是由操作系统保证的，是系统调用。
- > **进程通信**
  * > **管道(pipe)**
    + > 管道是一种半双工的通信方式，***数据只能单向流动***，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
  * > **有名管道 (namedpipe)**
    + > 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
  * > **信号量(semaphore)**
    + > 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
  * > **消息队列(messagequeue)**
    + > 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  * > **信号 (sinal)**
    + > 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
  * > **共享内存(shared memory)**
    + > 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
  * > **套接字(socket)**
    + > 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。
- > **线程间的通信方式**
  * > **锁机制：包括互斥锁、条件变量、读写锁**
  * > **信号量机制(Semaphore)**
    + > 包括无名线程信号量和命名线程信号量。
  * > **信号机制(Signal)**
    + > 类似进程间的信号处理。
  * > 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### 协程

一文讲透“进程，线程和协程” https://juejin.cn/post/6856990624399228935

### 线程池

设计一个线程池 https://liam.page/2022/05/05/design-a-thread-pool/
- > **为什么需要线程池？**
  * > 自 C++11 起，在 C++ 中使用线程就变得很简单。最基本地，可以用 `std::thread` 来管理一个线程。若是要异步地执行任务，搭配使用 `std::async` 和 `std::future` 也很方便。在有这些基础设施的基础上，我们为什么还需要线程池？或者说，我们什么时候需要线程池？
  * > 众所周知，线程作为一种系统资源，其创建和销毁是需要时间的。***因此，如果创建和销毁线程的时间和执行任务所需的时间处在同一个数量级，那么频繁地创建和销毁线程带来的性能损耗就会变得十分可观。此时，我们就要考虑使用线程池***。
- > **线程池应有哪些特点？**
  * > 线程池的本质就是一组待用的线程。在 C++ 中，它可以表示为一个 `std::thread` 的数组或是向量。在实际工程中，为便于进行可能的扩展，使用 `std::vector<std::thread>` 显然会更加合适。  
- > **完整实现**
  * > 完整实现可见 [Liam0205/toy-threadpool](https://github.com/Liam0205/toy-threadpool)，其中包括了单元测试和相比 `std::async` 的性能对比。

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 句柄

What is the difference between: Handle, Pointer and Reference https://stackoverflow.com/questions/13023405/what-is-the-difference-between-handle-pointer-and-reference

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

## 编码

网络传输——Base64详解
https://blog.csdn.net/wanghaobo920/article/details/8009575

UniCode编码表及部分不可见字符过滤方案
https://www.cnblogs.com/fan-yuan/p/8176886.html

### Big Endian 与 Little Endian

Endianness https://en.wikipedia.org/wiki/Endianness

理解字节序 https://www.ruanyifeng.com/blog/2016/11/byte-order.html
```
3.
首先，为什么会有小端字节序？
答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。
但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。

5.
字节序的处理，就是一句话：
"只有读取的时候，才必须区分字节序，其他情况都不用考虑。"
即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。
```

Big Endian与Little Endian区别 https://blog.csdn.net/wyzxg/article/details/5349896

:u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307::u6307:

# 小知识

### `len()` 或 `size()` 之类的函数的复杂度为什么大都是 `O(1)`？

Time Complexity of finding the length of an array https://stackoverflow.com/questions/45093097/time-complexity-of-finding-the-length-of-an-array
- https://stackoverflow.com/questions/45093097/time-complexity-of-finding-the-length-of-an-array/45093159#45093159
  * > You can generally always trade space for time when constructing algorithms.
  * > For example, when creating a collection, allocate a separate variable holding the size. Then increment that when adding an item to the collection and decrement it when removing something.
  * > Then, voilà, the size of the collection can then be obtained in `O(1)` time just by accessing that variable.
  * > And this appears to be what Python actually does, as per [this page](https://docs.python.org/3/c-api/structures.html), which states (checking of the Python source code shows that this is the action when requesting the size of a great many objects):
    >> `Py_SIZE(o)` - This macro is used to access the `ob_size` member of a Python object. It expands to `(((PyVarObject*)(o))->ob_size)`.

:u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272:

# 编程题目

<<按单词反转字符串>>
http://blog.csdn.net/xinpo66/article/details/20665187
