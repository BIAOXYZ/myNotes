
C++多线程并发基础入门教程 - zizbee的文章 - 知乎 https://zhuanlan.zhihu.com/p/194198073
- > 《C++ Concurrency in Action, Second Edition》这本书深入浅出的讲解了C++多线程知识；如果英文水平足够好，可以查阅英文原版，它也有中文译本，虽然翻译过来的质量不如原版，但英文原版阅读太费精力；我推荐新手或者有一定经验的人看这本书；下面提供了书栈网的电子版：
  * > C++ 并发编程实战 第二版 (C++ Concurrency in Action - SECOND EDITION) https://www.bookstack.cn/books/CPP-Concurrency-In-Action-2ed-2019
- > [C++高级——多线程编程](https://blog.nowcoder.net/n/88ed81f4787d4927ae2c38e24a53eb3b)
- > **2 C++多线程并发基础知识**
- > **2.1 创建线程**
  * > **只要创建了线程对象**（前提是，实例化std::thread对象时传递了“函数名/可调用对象”作为参数），**线程就开始执行**。
  * > 总之，**使用C++线程库启动线程，可以归结为构造`std::thread`对象**。
  * > 那么至此一个简单的多线程并发程序就编写完了吗？不，还没有。**当线程启动后，一定要在和线程相关联的`std::thread`对象销毁前，对线程运用`join()`或者`detach()`方法**。
  * > `join()`与`detach()`都是`std::thread`类的成员函数，是两种线程阻塞方法，***两者的区别是是否等待子线程执行结束***。
  * > 等待调用线程运行结束后当前线程再继续运行，例如，主函数中有一条语句`th1.join()`,那么执行到这里，主函数阻塞，直到`线程th1`运行结束，主函数再继续运行。
  * > 整个过程就相当于：你在处理某件事情（你是主线程），中途你让老王帮你办一个任务（与你同时执行）（创建线程1，该线程取名老王），又叫老李帮你办一件任务（创建线程2，该线程取名老李），现在你的一部分工作做完了，剩下的工作得用到他们的处理结果，那就调用"老王.join()"与"老李.join()"，至此你就需要等待（主线程阻塞），等他们把任务做完（子线程运行结束），你就可以继续你手头的工作了（主线程不再阻塞）。
  * > 一提到join,你脑海中就想起两个字，"等待"，而不是"加入"，这样就很容易理解join的功能。
    >> 【[:star:][`*`]】 //notes：其实最好的理解join的方式是“***插队***”吧。。。
  * > 调用`join()`会清理线程相关的存储部分，这代表了`join()`只能调用一次。使用`joinable()`来判断`join()`可否调用。同样，`detach()`也只能调用一次，一旦`detach()`后就无法`join()`了，有趣的是，`detach()`可否调用也是使用`joinable()`来判断。
  * > 如果使用`detach()`，就必须保证线程结束之前可访问数据的有效性，使用指针和引用需要格外谨慎，这点我们放到以后再聊。
- > **2.2 互斥量（锁）使用**
