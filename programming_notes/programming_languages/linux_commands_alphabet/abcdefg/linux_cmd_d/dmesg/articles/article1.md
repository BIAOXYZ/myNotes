
# 1

我的进程去哪儿了，谁杀了我的进程 https://www.cnblogs.com/xybaby/p/8098229.html
- > 一个大型系统一般包含多个进程，同一个服务也可能是有多个进程组成，那么可以将这组进程逐步更新：先让一部分进程停止提供服务，等待已有的请求都完毕之后，重启这些服务，然后再更新替他进程。 <br> 即使，我们需要关闭所有服务，也需要优雅（graceful）地停止这些进程。所谓的优雅，就是保证已有的请求都能处理完，需要持久化的状态、数据都保存成功，然后再结束进程，一般来说，可以通过发送信号或者通过哨兵（sentinel）来结束。 <br> 只要是预期内的进程结束，那么都是ok的。而预期之外的进程结束往往令程序员抓狂，线上服务器的问题往往意味着分分钟几位数的损失、KPI、年终奖......想想就很恐怖。
- > **Linux Signal**
  * > 一个进程的异常终止，通常有两种情况，一种是crash，另一种是被kill掉了。
  * > ***crash是指程序出现了自己无法解决的异常情况，只能终止，比如Python语言抛出了一个未被捕获的异常，就会结束程序***。对于C、C++，最有名的就是段错误（segmentation fault），如果在Linux下面，那么会生成coredump，程序员通过`gdb`（有可能）可以分析出crash的原因。当然，要生成coredump也是需要正确的设置，可以通过`ulimit`（`ulimit -c`）查看或者设置。
  * > 而进程被`kill`掉，就是其他进程给目标进程发送了信号（signal），当然也可以是自己给自己发的信号，而目标进程没有正确处理这些信号，或者根本没有机会（权力）处理这些信号，那么目标进程就有可能会终止。
  * > 信号是Unix-like系统进程间通信（`IPC`）的一种方式，***这种通知是异步的，信号是一种软中断，操作系统会将目标进程的正常执行流程暂停，然后处理信号***。如果 ***目标进程注册了相应的信号处理函数（signal handler），那么就会调用这个signal handler，否则会执行默认的信号处理函数***。
  * > 不同的操作系统，支持的信号可能略有差异，可以使用`kill -l`查看系统所有的信号。下面是Linux上常见的信号以及处理机制
    ```console
    信号 　　　值    处理动作 发出信号的原因 
    ---------------------------------------------------------------------- 
    SIGHUP   1        A   终端挂起或者控制进程终止 
    SIGINT   2        A   键盘中断（如break键被按下） 
    SIGQUIT  3        C   键盘的退出键被按下 
    SIGILL   4        C   非法指令 
    SIGABRT  6        C   由abort(3)发出的退出指令 
    SIGFPE   8        C   浮点异常 
    SIGKILL  9        AEF Kill信号 
    SIGSEGV  11       C   无效的内存引用 
    SIGPIPE  13       A   管道破裂: 写一个没有读端口的管道 
    SIGALRM  14       A   由alarm(2)发出的信号 
    SIGTERM  15       A   终止信号 
    SIGUSR1  30,10,16 A   用户自定义信号1 
    SIGUSR2  31,12,17 A   用户自定义信号2 
    SIGCHLD  20,17,18 B   子进程结束信号 
    SIGCONT  19,18,25     进程继续（曾被停止的进程） 
    SIGSTOP  17,19,23 DEF 终止进程 
    SIGTSTP  18,20,24 D   控制终端（tty）上按下停止键 
    SIGTTIN  21,21,26 D   后台进程企图从控制终端读 
    SIGTTOU  22,22,27 D   后台进程企图从控制终端写 
    ```
    > 处理动作一项中的字母含义如下
    ```console
    A　　缺省的动作是终止进程
    B　　缺省的动作是忽略此信号
    C　　缺省的动作是终止进程并进行内核映像转储（dump core）
    D　　缺省的动作是停止进程
    E　　信号不能被捕获
    F　　信号不能被忽略
    ```
- > 如果默认处理动作是C（coredump），那么就会生成coredump，然后终止进程，在上一篇文章[《啊，我的程序为啥卡住啦》](http://www.cnblogs.com/xybaby/p/8025435.html)中，提到用`kill -11 pid`来终止、调试卡住的程序，这个`11`就是指信号`SIGSEGV`。
- > 注意 **`SIGKILL` `SIGSTOP`这两个信号，既不可以被捕获，也不能被忽略**，就是说收到这两个信号，程序就会不留痕迹地终止。
- > **到底是什么信号**
  * > 从上面，我们可以看到，有很多信号都可以终止进程，如果我们没有针对某种信号指定处理函数，那么我们怎么知道进程是被哪一个进程kill掉了呢，那就是`strace`。
  * > 我们以一段简单的Python代码为例：
    ```py
    # -*- coding: utf-8 -*-
    def func():
        while True:
            pass
    if __name__ == '__main__':
        func()
    ```
- > **OOM**
  * > 关于进程收到了SIGKILL信号，有一种不得不提的情况，那就是OOM（out of memory），简单来说，就是当Linux系统内存不足，在大量使用swap之后，会kill掉内存占用最大的进程。这应该算操作系统系统自身的一种保护机制，以防更多的进程不能正常工作。关于OOM killer，网上有详尽的资料介绍，在这里只是简单看看现象。
  * > 下面是一个简单的Python程序，该程序会无限的分配内存，直到内存不足：
  * > stackoverflow上 [who-killed-my-process-and-why](https://stackoverflow.com/questions/726690/who-killed-my-process-and-why) 一文指出，由于outofmemory被kill掉的进程，会在`/var/log`下的某个文件中留下最终的遗迹，在笔者使用的debian系统中，可以通过`dmesg`查看：`dmesg －T | grep -E -i -B100 'killed process'`
