
# postgres20

postgresql内核开发 https://blog.csdn.net/postgres20/category_6538868.html
- postgresql源码阅读快速上手 https://blog.csdn.net/postgres20/article/details/53354330
- postgresql内核语法解析器详解 https://blog.csdn.net/postgres20/article/details/54709860

postgresql源码阅读快速上手 https://blog.csdn.net/postgres20/article/details/53354330  
- > 上面说的是运行中中断，实际使用中这样的操作场景可能比较少，更多的往往是出错情况下，想深究错误原因需要调试下。比方说执行某个语句，没有得出想要的结果，报错了,给出的错误信息不满意，或者说就是要看下执行流程，需要研究下代码，如何下手？下断点！当然，要在合适的地方下断点。pg内核报错接口已经封装好，只要在报错函数那下断点，所有错误都能断到，断到之后再看代码执行流程就很容易了，错误入口函数有这两个
  ```c
  errmsg(const char *fmt,...)
  elog_finish(int elevel, const char *fmt,...)
  ```
  > 找到这两个两个函数分别下断点，就能断到所有的内核报错信息，下面举个简单例子：`select *from txx;`   --txx表不存在，会报错，我们看堆栈。如图，在 `errmsg` 处被断到了。
- > 【[:star:][`*`]】 对于 `errmsg` 和 `elog_finish` 这两个报错接口的区别，大家可能有些疑问，我稍微介绍下。在代码中，`errmsg` 被包成了 `ereport` 函数使用，`elog_finish` 被包成了 `elog` 函数使用，***对于ERROR级别的错误，`ereport`报的错是正常的错误，而`elog`报的错则是不正常的的错误***。那么正常的错误，不正常的错误是什么意思？就拿上面的例子来说，我查一个表，这个表不存在，这就是正常的错误，但是如果一个值，按照设计只可能有三种值，比方说switch case1 case2 case3分别对应处理了，然后为了程序健壮性我们对其它所情况都报错，就应该用elog报，因为这是正常情况下不应该出现的错误，很可能是一个未初始化的值引发的。举个通俗点的例子，打篮球时别人进攻我防守不小心打手了，这犯规了，这种犯规就是正常的错误（用 `ereport`)，但是别人投球时我突然把篮筐扯掉不让人进，这肯定也犯规了，但这是非正常犯规，规则中没办法定义但的确又犯规（用 `elog`)。
  >> //notes：注意，可以 `b	errmsg` 和 `b	elog_finish` 成功打断点；但是它俩的封装（`ereport` 和 `elog`）是打不上断点的。

:u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272::u5272:
