
# 11

Apache Cloudberry 内核探究｜Runtime Filter 技术深度解析（一） https://mp.weixin.qq.com/s/9gmoGwZ6mq74FpoBd7fXQQ
- > 为什么传统 Hash Join 在大表上会成为性能瓶颈？
  * > 所谓 Runtime Filter，本质上是 在查询执行时根据小表 Join Key 动态生成的过滤器，将其“提前”下推到大表扫描节点，对大表行做快速预过滤，让那些不可能匹配的行直接在扫描时就被丢弃。
  * > 它并不复杂：
    + > 在小表构建哈希表时，同时根据 Join Key 创建 Bloom Filter（或 Range Filter）。
    + > 将这个过滤器下推到大表扫描（SeqScan）阶段。在大表扫描时，Join Key 会先经过过滤器检查，如果不可能命中，直接丢弃。
  * > 结果是，大表参与 Join 的行数锐减，执行时间随之下降，用户感觉就是：“查询快了不少。”
  * > 值得一提的是，Runtime Filter 并不是 Cloudberry 独有的优化，Spark SQL、Trino（Presto）、Apache Doris 等主流系统都早已在生产环境使用这一技术。
  * > 在 TPC-H、TPC-DS 等标准测试中，Runtime Filter 可以帮助部分 Join-heavy 的查询实现 2-10 倍的加速，且这些加速并不依赖于复杂调优参数，而是来源于最朴素的道理：“能不处理的行就不要处理。”
- > Cloudberry 是如何实现 Runtime Filter 的？
  * > 首先，我们使用 Bloom Filter 作为主要过滤器类型。原因很简单：Bloom Filter 是一种概率型过滤器，***占用空间极小（通常几个 MB）***，通过多个哈希函数判断某个值是否可能存在，即便存在假阳性（放行无效行），也不会出现假阴性（误过滤正确行），这保证了最终结果的一致性。
- > 实际效果怎么样？
  * > 在 Cloudberry 的性能基准测试中，我们使用了 TPC-DS 10GB 和 100GB 数据集进行了对比：
    + > 在 10GB 测试集上，开启 Runtime Filter 后，查询总耗时从 939 秒降低到 779 秒，缩短了约 17%。
    + > 在 100GB 测试集上，从 5270 秒降低到 4365 秒，提升同样在 17% 左右。

# 03

内核探究｜Apache Cloudberry 并行查询技术解析 https://mp.weixin.qq.com/s/0xNbPGtVIJKHepvL__qDYw

# 02

内核探究｜Apache Cloudberry 透明数据加密（TDE）技术解析 https://mp.weixin.qq.com/s/UKlhVZinRXL282piXm1Zhg
