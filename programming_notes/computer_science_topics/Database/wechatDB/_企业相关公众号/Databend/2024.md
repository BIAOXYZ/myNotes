
# 11

存算分离的过去、现在和未来 https://mp.weixin.qq.com/s/DCIHi5XIeAq_LgYVPTRCVQ
- > **存算一体架构局限性**
  * > 在传统的数据处理架构中，计算和存储往往是紧密耦合在一起的。这种存算一体的架构虽然在早期的数据需求中表现优异，但随着业务复杂度和数据量的激增，逐渐显现出了一些无法克服的缺陷：
    + > 1.扩展性不足：新增一个计算节点时，数据（包括 MetaData 和 Data）需要在节点之间同步，导致扩展效率低下，且增加了系统的复杂性和管理成本；
    + > 2.资源分配不灵活：由于计算与存储资源是紧密耦合的，因此在业务负载发生变化时，⽆法根据业务负载做资源动态分配，⽆法灵活调整计算和存储资源，资源利⽤率低 (Node 多副本)，成本控制难；
    + > 3.故障影响大：在这种架构中，计算节点和存储节点之间共享数据，导致一个节点的故障可能会影响整个系统的稳定性，⽆法根据业务类型做资源隔离，资源争抢、故障影响范围⼤，⽆法保证稳定性。
- > **存算分离进化：存算一体到分离**
  * > 存算分离架构的发展可以大致分为三个阶段，每个阶段都在逐步解决存算一体架构中的缺陷，并使数据处理系统变得更加灵活和高效。
  * > **存算分离 L0：Metadata+Data，状态非常重**
    + > 在早期阶段，例如 ClickHouse，在 `MergeTree` 写入流程中，元数据与业务数据的耦合程度很高。这种方式的存储状态非常重，节点需要频繁同步数据，导致扩展和管理都极其复杂。
  * > **存算分离 L1：Metadata 状态，状态重**
    + > 在 L1 阶段，以 ClickHouse 的 `SharedMergeTree` 写入流程为例（SharedMergeTree 不开源），元数据与数据的分离有了一定的改进。元数据独立存储在集中化的系统中（如 Keeper，类似 ZooKeeper），而业务数据则可以存储在对象存储中，例如 S3。虽然这种方式减轻了数据节点的负担，但元数据管理依旧是系统的瓶颈。
  * > **存算分离 L2：计算无状态化**
    + > 随着对计算资源和存储资源的独立需求不断增长，Databend 使用了彻底的存算分离架构。在 L2 级别，计算节点彻底无状态化，状态全部持久化在对象存储中。这使得计算节点可以根据负载需求弹性调整，启动时间也缩短到了小于 5 秒，大大提升了系统的可扩展性和资源利用率。
  * > **存算一体为什么不能“进化”到 L2？**
    + > 第二，分布式网络传输挑战。***在分布式架构下，数据要在节点间做 Shuffle。假如要做一个很复杂的 join，哪个节点需要数据，就拉到哪个节点。但像 Databend 这种真正的存算分离架构，数据都在 S3 上，传的不是数据实体，而是一个文件路径。系统会告诉你要的数据在哪个位置，而不是把数据内容都传给节点***。这是 Databend 做完全存算分离时做出的一个巨大改变，既减少了网络传输。这对 ClickHouse 等传统存算一体架构来说就很难，需要重新设计交互方式，改很多东西；
    + > 第三，Metadata 膨胀挑战。***ClickHouse 虽然将数据剥离了，但 Metadata 还没剥离，随着数据量的增长，Metadata 会越来越大***。一旦高并发来了，会直接压垮。***所以 ClickHouse 每个节点即使是存算分离，也要在本地维护一份自己的 Metadata ，以减少 ZooKeeper 的压力***；
    + > 第四，调度器。调度器在传统存算一体架构中，是面向本地盘设计的。它认为本地盘 IO 是无限的，只要尽量把随机的变成顺序，就可以把性能提上去。但是对象存储的设计完全不一样，对象存储只要有足够的并行，就能把带宽拉满，所以调度器上也要改很多东西；
