
# 01

`count(*)` 比 `count(1)` 快 https://mp.weixin.qq.com/s/qKnHbdf9JaPnNIq1TC002g  【`1.6`】
- > PostgreSQL 19 preview - `count(*)` 比 `count(1)` 快
  * > PG 19 优化 `count(表达式)` 性能, 当表达式中包含非空列, 且不包含order by或distinct时, 将转换为 `count(*)`. 从而提升性能.
  * > 为什么能提升性能, 主要是表达式的计算和deform tuple(解构元组)以提取列值的开销. 如果是 `count(*)` 可以完全规避计算和deform.
  * > https://github.com/postgres/postgres/commit/42473b3b31238b15cc3c030b4416b2ee79508d8c
- > 详细解读
  * > 1.核心优化：`COUNT(非空表达式)` 转换为 `COUNT(*)`
    + > 问题背景： 在 SQL 中，***`COUNT(expression)` 只会计算 expression 结果为非 NULL 的行数，而 `COUNT(*)` 总是计算所有行数***。如果用户对一个保证非空 (NOT NULL) 的列或表达式进行计数（例如 `COUNT(1)` 或 `COUNT(非空列)`），那么 `COUNT(expression)` 的结果与 `COUNT(*)` 是相同的。
    + > 性能瓶颈： 即使是像 `COUNT(1)` 这样看起来简单的表达式，以前 PostgreSQL 也需要额外的开销来计算这个表达式的值（例如 1），并检查它是否为 NULL。对于包含许多列的大型表，这个过程可能涉及“解构元组 (deforming the tuple)”以提取列值，从而带来不必要的性能开销。
    + > 补丁实现： 这个补丁引入了一个优化，允许查询规划器在以下条件满足时，将 `COUNT(expression)` 自动重写为更高效的 `COUNT(*)`：
      - > expression 保证非 NULL。
      - > `COUNT()` 调用中不包含 ORDER BY 或 DISTINCT 子句。
- 回复：
  * > 和 miniob 的优化很像，都是通过判断express是否符合某些条件把expr替换成1，达到聚合加速的目的
