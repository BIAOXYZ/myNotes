
我是 Redis，MySQL 大哥被我害惨了！ https://www.ithome.com/0/657/002.htm || https://mp.weixin.qq.com/s/FLqhzfVkakwBjLqIJ-1ezA
- > **我是 Redis**
  * > 你好，我是 Redis，一个叫 Antirez 的男人把我带到了这个世界上。
- > **缓存过期 && 缓存淘汰**
  * > 我眼里可揉不得沙子！于是在原来定期删除的基础上，又加了一招：那些原来逃脱我随机选择算法的键值，一旦遇到查询请求，被我发现已经超期了，那我就绝不客气，立即删除。这种方式因为是被动式触发的，不查询就不会发生，所以也叫**惰性删除**！
  * > 可是，还是有部分键值，既逃脱了我的随机选择算法，又一直没有被查询，导致它们一直逍遥法外！而与此同时，可以使用的内存空间却越来越少。而且就算退一步讲，我能够把过期的数据都删除掉，那万一过期时间设置的很长，还没等到我去清理，内存就吃满了，一样要吃枣药丸，所以我还得想个办法。我苦思良久，终于憋出了个大招：**内存淘汰策略**，这一次我要彻底解决问题！我提供了 8 种策略供应用程序选择，用于我遇到内存不足时该如何决策：
- >**缓存穿透 && 布隆过滤器**
  * > 我的日子过的还挺舒坦，不过 MySQL 大哥就没我这么舒坦了，有时候遇到些烦人的请求，查询的数据不存在，MySQL 就要白忙活一场！不仅如此，因为不存在，我也没法缓存啊，导致同样的请求来了每次都要去让 MySQL 白忙活一场。我作为缓存的价值就没得到体现啦！这就是人们常说的**缓存穿透**。
  * > 这一来二去，MySQL 大哥忍不住了：“唉，兄弟，能不能帮忙想个办法，把那些明知道不会有结果的查询请求给我挡一下”。这时我想到了我的另外一个好朋友：**布隆过滤器**。
- > **缓存击穿 && 缓存雪崩**
  * > 有一次，MySQL 那家伙正优哉游哉的摸鱼，突然一大堆请求给他怼了过去，给他打了一个措手不及。一阵忙活之后，MySQL 怒气冲冲的找到了我，“兄弟，咋回事啊，怎么一下子来的这么猛”。 <br> 我查看了日志，赶紧解释到：“大哥，实在不好意思，刚刚有一个热点数据到了过期时间，被我删掉了，不巧的是随后就有对这个数据的大量查询请求来了，我这里已经删了，所以请求都发到你那里来了”
  * > 那一天，又出现了大量的网络请求发到了 MySQL 那边，比上一次的规模大得多，MySQL 大哥一会儿功夫就给干趴下了好几次！等了好半天这一波流量才算过去，MySQL 才缓过神来。“老弟，这一次又是什么原因？”，MySQL 大哥累的没了力气。 <br> “这一次比上一次更不巧，这一次是一大批数据几乎同时过了有效期，然后又发生了很多对这些数据的请求，所以比起上一次这规模更大了”。
  * > 后来，我俩去找应用程序商量了，不仅把键值的过期时间随机了一下，还设置了热点数据永不过期，这个问题缓解了不少。哦对了，我们还把这两次发生的问题分别取了个名字：**缓存击穿**和**缓存雪崩**。

CPU 被挖矿，Redis 竟是内鬼！ https://www.ithome.com/0/656/839.htm || https://mp.weixin.qq.com/s/YJlkue9zSBes6tFVxMZ2IA
- > 虽说这 Redis 常被用来当做缓存，数据只存在于内存中，却也能通过 SAVE 命令将内存中的数据保存到磁盘文件中以便持久化存储。只见 Redis 刚打开文件，准备写入，不知何处突然冲出几个大汉将其擒住。到底是怎么回事？Redis 一脸懵。这事还得要从一个月之前说起。
- > “`sshd` 留一下，其他人可以先撤了”，部长说到。
- > 助理关上了大门，安全部长轻声说到：“据刚刚得到的消息，有人非法远程登录了进来，这挖矿病毒极有可能就是被人远程上传了进来” <br> `sshd` 一听这话大惊失色，慌忙问道：“难道登录密码泄露了？” <br> “应该不是，是使用的公私钥免密登录”，一旁的助理回答到。“你看，在 `/root/.ssh/authorized_keys` 文件中，我们发现了一个新的登录公钥，这在之前是没有的”，随后，助理输出了这文件的内容：
- > “绝不是我干的”，`sshd` 急忙撇清。 <br> “远程登录，这不是你负责的业务吗？”，助理问到。 <br>  “确实是我负责，但我也只是按程序办事，他能用公私钥登录的前提是得先把公钥写入进来啊，所以到底是谁写进来的，这才是关键！”，`sshd` 说到。
- > “你持久化存储，为什么会写到 `authorized_keys` 文件里面来？”，`sshd` 继续质问。 <br> “刚刚收到几条命令，设置了持久化存储的文件名就是这个，不信你看”，说罢，Redis 拿出了刚刚收到的几条命令：
  ```console
  CONFIG SET dir /root/.ssh
  CONFIG SET dbfilename authorized_keys
  SAVE
  ```
  > “第一条指定保存路径，第二条指定保存的文件名，第三条就是保存数据到文件了”，Redis 继续解释到。
- > 安全部长仔细看着几条命令，说道：“把你要写入的数据给我看看” <br> “这可有点多，你等一下”，说罢，Redis 拿出了所有的键值数据，散落一地。 <br> “部长快看！”，`sshd` 突然大叫。顺着他手指的方向，一个醒目的公钥出现在了大家面前。
- > “给你下命令的究竟是谁，又是怎么连接上你的？”，部长问到。Redis 不好意思的低下了头，只说道：“不瞒您说，我这默认就没有密码，谁都可以连进来”。
- 回复里的：
  * > Redis默认端口默认密码导致被利用篡改authorized_keys,然后用来挖矿,全文完?
  * > 省流：redis没设密码，被修改权限了
  * > redis部署后不给单独设置一个nologin的用户，然后权限最小化？
  * > 我玩docker开放远程damon连接，没有用tls，才一晚上就被入侵了
  * > 碰到过，我的是Redis不设密码，但是防火墙设置来源IP，有一次重装了ufw，防火墙规则重置了，然后Redis被入侵，通过Redis放置了挖矿病毒，幸好不是root权限，通过Redis干不了别的
  * > redis mongodb mysql都表示，你们这帮傻子暴露公网，还若口令，怪谁？
  * > 我的mongodb没设密码数据被加密了
  * > 中过一次，千万别放开外网端口,要开必须限制证书
  * > redis居然有root权限，不是应用权限启动
    >> 【[:star:][`*`]】 //notes：突然发现了 pg 确实有先见之明。。。就不准 root 用。。。

CPU 深夜狂飙，一帮大佬都傻眼了・・・ https://www.ithome.com/0/656/692.htm || https://mp.weixin.qq.com/s/HWfSdwfYnknJEhfaTPOhyw
- > “部长，我俩都是遍历的 `/proc/` 目录下的内容，按理说，所有的进程都会在这里啊，我也想不通为什么找不到・・・”，`top` 老哥委屈的说到。
- > “就是通过 `opendir`/`readdir` 这些系统调用函数来遍历的，这都是帝国提供的标准接口，应该不会出错，除非・・・”，说到这，`top` 打住了。 <br> “除非什么？” <br> “除非这些系统调用把那个进程给过滤掉了，那样的话我就看不到了，难道有人潜入帝国内核，篡改了系统调用？”
- > 眼看部长急的团团转，一旁的 `netstat` 起身说到：“部长，我之前结识一好友，名叫 `unhide`，捉拿隐藏进程是他的拿手好戏，要不请他来试试？”
- > `top` 有点表示怀疑，问到：“敢问兄台用的什么路数，为何我等都看不到这几个进程的存在？” <br> `unhide` 笑道：“没什么神秘的，其实我也是遍历 `/proc/` 目录，和你们不同的是，我不用 `readdir`，而是从进程 id 最小到最大，挨个访问 `/proc/$pid` 目录，一旦发现目录存在而且不在 `ps` 老哥的输出结果中，那这就是一个隐藏进程。” <br> 一旁的 `ps` 笑道：“原来还有我的功劳呐”
- > “大家请看，进程打开的文件都会在 `/proc/pid/fd` 目录下，socket 也是文件，我刚看了一下，这个进程刚好有一个 socket。再结合 `/ proc / tcp` 信息，可以确定这个 socket 就是目标端口号 7777 的那一条！”
- > “部长，`rm` 那小子是假冒的，今天他骗了我们，病毒根本没删掉，又卷土重来了！”部长望向远处的天空，CPU 工厂门口的风扇又开始疯狂地转了起来・・・
- 回复里的：
  * > rm没有假冒，rm对应的系统调用被hook了
  * > 病毒可以伪装成检测程序吗？我们单位的防火墙简直就是一层纸，有黑产轻易通过回避关键词和多ip注册的方法捅破我们的风控，我们只能用人力车轮战一个个手动冻结违规账号，然而这已经持续块1周了，我们还不停地被攻击和抹黑。。。。。虽然不是我们的业务，我也只是摸鱼吃瓜，但是老板赚不到钱我们下面的早晚也要寄。。。。

CPU 加了缓存后，有人急了～ https://www.ithome.com/0/654/674.htm || https://mp.weixin.qq.com/s/pntcKUaCyetWHDsOZHwU2Q

主板上这家伙，要当 CPU 和内存的中间商 https://www.ithome.com/0/652/903.htm || https://mp.weixin.qq.com/s/UKPagzvcwyY5RzOLWIff5g

中断还是轮询？取个数据包真麻烦 || https://mp.weixin.qq.com/s/QmZP0P4BrSJ1p6YI6cmyVQ

什么？一个核同时执行两个线程？ https://www.ithome.com/0/646/476.htm || https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg

就为了一个原子操作，其他 CPU 核心罢工了 https://www.ithome.com/0/645/439.htm || https://mp.weixin.qq.com/s/jx0EajGXGrM3fR14P9Bm7Q

一个整数＋1 引发的灾难 https://www.ithome.com/0/645/040.htm || https://mp.weixin.qq.com/s/hFWSItFYIzWLr_RFne2lBA

CPU 瞒着内存竟干出这种事 https://www.ithome.com/0/644/894.htm || https://mp.weixin.qq.com/s/Pm_jdPUB_9Aq8hhpbrF5QA

可怕！CPU 竟成了黑客的帮凶 https://www.ithome.com/0/644/724.htm || https://mp.weixin.qq.com/s/XEDCCQntIRghWhfigciWSA  【from `编程技术宇宙`】

完了！CPU 一味求快出事儿了 https://www.ithome.com/0/644/626.htm  【from `编程技术宇宙`】
- 回复里的：
  * > 乱序执行部分实际上既讲了流水线，又讲了乱序执行，而乱序执行部分反而比较短，也没有配图，可能会造成混乱。 <br> 乱序执行是基于这样的事实，即一些指令并不能在一个运算(Execute)周期内完成，比如乘法和除法可能需要高达几十周期，而负责数值计算的组件ALU支持的各种运算可以同时进行，甚至许多架构中同一个核心会配备多个进行同种运算的单元。这样在计算 c=b×a 的同时，如果下一个指令与上一条指令运算结果无关，比如 d=b+a，就可以同时运行；而如果下一条指令依赖上一条的结果，比如 e=c-b，就需要等待c的值计算完成。这种并行被称为指令级并行。 <br> 至于如何确定指令之间的依赖关系，以及如何管理指令的执行与等待，就相对复杂，可以自行搜索tomasulo算法。这也是为什么现代处理器分成前端和后端，以及可以使用数量远多于指令集所支持的寄存器的原因
    >> 好家伙，昨天刚考完tomasulo算法，感觉又复习了一遍计算机体系结构
  * > 通俗易懂的讲解方式，并不代表就要用这种幼稚的表达方式，好好说人话也可以做到通俗易懂的讲解的。建议可以去看看B站硬件茶谈的科普视频
