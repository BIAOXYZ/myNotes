
# 2024.11

耗费百万美元，这个程序员把自家房子打造成游戏聚会基地，无数人羡慕不已！ https://mp.weixin.qq.com/s/UN7sB778IUSEJpdf1e5T9g

漫画 | 统治软件开发的著名定律，程序员根本无处可逃！ https://mp.weixin.qq.com/s/DDbt5nnklxxu7p6F4Wojjw
- > `古德哈特定律`（`Goodhart's law`）：当一个措施本身成为目标时，它就不再是一个好的措施。
- > `霍夫斯塔特定律`（`Hofstadter's law`）：事情总是要花费比你预想更长的时间。
- > 后记：其实类似上文的定律很多，比如`80/20原则`：代码中80%的错误都是由代码中的20%引起的。另外，公司80%的工作是由20%的员工完成的，问题是你并不总是清楚谁是那20%；再比如著名的`康威定律`：软件的任何一部分都反应了创建它的组织结构。许多组织都根据他们的技能来划分团队。因此会有前端开发、后端开发和数据库开发组成的团队，这会导致某人想要修改一个不属于自己领域的东西会很难。最好是按照有边界的上下文(bounded context)来规划团队，像微服务这样的架构就是围绕服务边界而不是孤立的技术体系划分来组织他们的团队。还有`伯斯塔尔定律(Postel's Law)`：发送时要保守，接收时要大方。Jon Postel 最初认为正是这个原则让TCP协议的实现很健壮。一些人认为这正是 HTML 很成功的原因，也有一些人认为这正是 HTML 很失败的原因。（因为HTML可以写得不那么严格，但是浏览器依然可以解析它）
- 回复：
  * > 补一个28定律：一个需求的核心功能大概只需20%的代码就能完成，剩下80%的代码主要是考虑各种特殊场景
  * > 我们面对的代码往往是一个结果，而形成这个结果的过程早就在历史中灰飞烟灭了。所以，我们真的很难对这个结果进行快速改动，因为它的形成过程是会影响改动的方向与策略的。这估计就是遗留代码最难处理的地方了。估计得向考古学借鉴一些经验方法才行。
    >> 这时候就体现软件工程化的作用了
  * > 擦屁股的纸只有20%是真正起作用的，但是一旦去掉没用的80%就会粘到手上
  * > ***想偷懒，就一定会发生问题***
  * > 我们这里就有代码量，我把能可以复用的方法都是直接复制过来，我怕我的代码量垫底
  * > 1.灯泡质量太好反而降低销售量，你又不会在一个公司待太久，所以不必花太多时间过度考虑代码优雅和性能问题，说不准明天它就会被需求推翻，或者，你被公司干翻。所以要相信后人的智慧，创造就业岗位机会造福于世 2.不用把公司当自己家，只要进了公司，且不是管理岗，你的能力产出在平均水平就可以了，过度产出只会成为工贼，卷死自己和道友，并且一分钱没有，只要你不够上心负责，始终会有一个角色人会来替你上心负责，并且分担你的工作量
- 个人补充链接：
  * Goodhart's law https://en.wikipedia.org/wiki/Goodhart%27s_law || 古德哈特定律 https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%BE%B7%E5%93%88%E7%89%B9%E5%AE%9A%E5%BE%8B
    + > `"When a measure becomes a target, it ceases to be a good measure."` || `“一项指标一旦变成了目标，它将不再是个好指标。”`
  * Hofstadter's law https://en.wikipedia.org/wiki/Hofstadter%27s_law

# 2024.08

Python太烂了！比C语言慢71倍！消耗的能量是C语言的75倍！ https://mp.weixin.qq.com/s/ulVGTL6T8icctrcEhEFLeA
- > 最近看到一个有趣的编程语言研究，它把27种编程语言放到一起做了一个基准测试。
- > 一般的基准测试无非是看看哪个编程语言最快，而这个研究还要看看谁消耗的能量最高。
- > 其中的一个结果让人震惊，Python竟然比C慢71倍，消耗的能量居然是C的75倍！
- > 这个研究是葡萄牙的一个研究所做的，他们用了一个叫做“The Computer Language Benchmarks Game”测试集。
- > 这个测试集很有趣，既包括程序员熟悉的“二叉树遍历”，也包括“N体问题”这样的天体运动模拟，目的是尽可能多地覆盖到更多领域。
- > 对于程序的运行时间很好计算，记录下开始时间和结束时间，相减就出来了。
- > 对于程序的能耗，他们使用了Intel的`RAPL（Running Average Power Limit）`，这是一种硬件功能，可以监控CPU、内存、GPU能耗，然后通过API来访问。
- > 原论文链接： https://haslab.github.io/SAFER/scp21.pdf
- 回复：
  * > 十多年前CSDN论坛有过一场关于C和C++哪个快的大论战 双方都是当时国内小有名气的程序员，也是选了几种基准用例进行比较，测试环境、计时算法都有讲究，理论上是C快，不过我记得当时争论的结果是C++快
    >> 现在C++代码能提供更多的信息给编译器，有利于其对程序进行优化，个人认为在某些情况下会比C效率高。
    >>> 是这样，现代c++更倾向于在编译期把很多运算功能给做了，这样大量减少了运行时的工作量。所以在某些人或工作上，c++可能更快。但多数情况，对于普通程序员写的程序还是c快一些。

# 2024.07

两位巨佬吃了一顿晚饭，整个互联网彻底被改变了！ https://mp.weixin.qq.com/s/wsDGJTRLjdG8WfdDDlDV8w
- > 大家都知道Unicode只是规定了每个字符用什么编码，但是没有规定如何去存储， 当时Plan 9 采用了一个叫做ISO 10646 UTF编码， 但是这个编码实在不怎么样， 按照Rob Pike的话说：我们恨这个编码。
- > **2**
  * > 故事讲完了，我们来看看为什么UTF-8能流行起来。
  * > 大家知道英文字母用一个字节保存就够了，如果Unicode规定每个英文字符也用两个字节或三个字节来保存，那每个英文字母前面势必要补上0， 文本文件要大两到三倍。
  * > 这是巨大的浪费，肯定不行。
  * > Rob和Ken的设计的UTF-8就比较聪明， 看看这个表：
- > **3**
  * > 1.兼容ASCII，表格中的第一行就是为ASCII所设。 <br> 多字节编码的每个字节的最高位永远是 1，而 ASCII 字符编码的最高位是 0，所以从根本上杜绝了编码冲突。
  * > 2.第一个字节就指明了后续的长度 <br> 当程序面对一个字节流的时候，只需要读出第一个字节最前面有几个1 ，就知道这个字符的长度，解码很方便。
  * > 3.前缀码 <br> 大家仔细观察下， UTF-8中没有任何合法字符是其他字符的前缀， 这样就带来了一个好处：支持程序快速地跳过有问题的字节，然后正常解码。
- 回复：
  * > mysql存储的字符串长度使用1-2字节, 也是借鉴了utf8这种思想. 第1bit为0 就表示使用1字节表示长度, 为1  就读2字节,  第1字节超过128的部分*256加上第2字节就是实际的值.  虽然表示的范围缩短了(一半). 但是存储的空间也减少了

漫画 | 浏览器真是一个比一个无耻！ https://mp.weixin.qq.com/s/GcfKEpkraNHfnYMdrGqMcA
- > 这个User Agent字符串之所以这么古怪， 要从20多年前的Mosaic说起。

世界上最大的盗版网站，遇到麻烦了！ https://mp.weixin.qq.com/s/WJ_A_WxjLzV_YTnpeGgWTA
- > **01 把互联网“存”起来**
  * > 这是个疯狂的想法，不过，还真有人这么干了！
  * > 照片中这位老帅哥叫做`Brewster Kahle`， 他的梦想就是做这件事情：把整个互联网都存起来！
- > **02 海量数据**
  * > 到目前为止，互联网档案馆已经保存了：
    ```console
    8350 亿个网页
    4400 万本书籍和文本
    100 万个软件程序
    1500万 录音（包括25.5万个音乐会）
    1060万个视频 （包括260个电视节目）
    480万张图片
    ```
  * > 仅仅是单个副本就占用了`145PB`的空间（所有的内容至少存储两个副本）。
  * > 如果你也想找古老的资料，也可以去试一试： https://web.archive.org/

# 2024.05

微软开源了操作系统，注释中藏着一个大秘密！ https://mp.weixin.qq.com/s/-N38xZ1go8_dUpkQOTtcMw
- > **1**
  * > 美国华盛顿州的西雅图，有个叫西雅图计算机产品（简称SCP）公司决定采用Intel的8086来组装个人电脑，但是却没有合适的操作系统可用。
  * > 于是公司的`蒂姆·帕特森` (`Tim Paterson`)写了一个操作系统，名称叫做QDOS，意思是`Quick and Dirty Disk Operating System，Quick and Dirty`，这名称，公司竟然叫得出口。
  * > 1981年，盖茨抓住了一个千载难逢的机会：为蓝色巨人IBM的PC提供操作系统。
  * > 这时候的盖茨绝对是空手套白狼，他连操作系统都没有，就敢和IBM签合同。
  * > 微软和同在西雅图的SCP公司之前有业务往来，这时候盖茨就发现了QDOS，他非常果断，立刻用5万美元买断QDOS，并且把作者蒂姆·帕特森也挖了过来，让他把QDOS移植到配有8088 CPU的IBM PC上。
  * > 当然，不能叫QDOS这么难听的名字了，新名字叫MS-DOS。
  * > Mark Zbikowski在微软也是一个传奇程序员，他给DOS贡献了分层目录结构，和可安装设备驱动（后来成了即插即用），后来参与了Windows NT的开发，是文件系统架构师和开发经理。
  * > ***就像PK把自己的名字雕刻在Zip文件格式中一样，`Mark Zbikowski` 也把自己的名字刻在了DOS可执行文件里，这种文件的Magic Number是：`4D 5A` ，即`MZ`***。
- > **2**
  * > 如果不是有个叫OwnedByWuigi用户手快，fork了最早发布的DOS4.0代码仓库，我们可能永远都不知道有这回事儿。 https://github.com/OwnedByWuigi/DOS/blob/ffd70f8b4fb77e2e6affbf1fad2fd8c349f0369f/v4.0/src/DOS/STRIN.ASM#L70 
  * > 程序员经常在代码注释中看到脏话，比如：
- 回复：
  * > 那段代码截图的意思，是先比较一下AL寄存器和ctrl-F的值，'F'-'@'就是计算ctrl-F。如果相等则跳转到GETCH，我猜是从键盘获取一个字符。注解是说，TP忽略ctrl-F，因为他的BIOS可能没有清除（后面我猜是cache，就是键盘缓冲区）。 <br> 我猜测是CTRL-F是某个热键可以跳转到某段处理程序，BIOS应该清除键盘缓冲以免后续程序处理多余的CTRL-F，但是兼容机的BIOS是逆向工程的，也许有些兼容机没有清除缓冲，因此要加这段清理缓冲的判断。GETCH就是从键盘缓冲区取一个字符，达到从缓冲删除CTRL-F的目的。不过他没有用CALL而是JZ，GETCH可能不是函数而是一段不同的逻辑
